---
title: Observability
sidebarTitle: Observability
description: Monitor and track your Stagehand automation with comprehensive session visibility, performance metrics, and analytics
---

Stagehand provides powerful observability features to help you monitor, track performance, and analyze your browser automation workflows. Focus on session monitoring, resource usage, and operational insights for both Browserbase and local environments.

## Browserbase Session Monitoring

When running on Browserbase, you gain access to comprehensive cloud-based monitoring and session management through the Browserbase API and dashboard.

<div style={{ textAlign: "center" }}>
  <img src="/media/observability.gif" alt="Browserbase Session Observability" width="400" />
</div>

### Live Session Visibility

Browserbase provides real-time visibility into your automation sessions:

**Session Dashboard Features**
- Real-time browser screen recording and replay
- Network request monitoring with detailed timing
- JavaScript console logs and error tracking
- CPU and memory usage metrics
- Session status and duration tracking

**Session Management & API Access**
<CodeGroup>
```typescript TypeScript
import { Stagehand } from "@browserbase/stagehand";

const stagehand = new Stagehand({
  env: "BROWSERBASE",
  apiKey: process.env.BROWSERBASE_API_KEY,
  projectId: process.env.BROWSERBASE_PROJECT_ID,
});

await stagehand.init();

// Access session details
console.log("Session ID:", stagehand.sessionId);
console.log("Session URL:", `https://app.browserbase.com/sessions/${stagehand.sessionId}`);

// Retrieve session information via API
const sessionInfo = await fetch(`https://api.browserbase.com/v1/sessions/${stagehand.sessionId}`, {
  headers: {
    'X-BB-API-Key': process.env.BROWSERBASE_API_KEY,
  }
}).then(res => res.json());

console.log("Session status:", sessionInfo.status);
console.log("Session region:", sessionInfo.region);
console.log("CPU usage:", sessionInfo.avgCpuUsage);
console.log("Memory usage:", sessionInfo.memoryUsage);
console.log("Proxy bytes:", sessionInfo.proxyBytes);
```

```python Python
import os
import requests
from stagehand import Stagehand

stagehand = Stagehand(
    env="BROWSERBASE",
    api_key=os.getenv("BROWSERBASE_API_KEY"),
    project_id=os.getenv("BROWSERBASE_PROJECT_ID"),
)

await stagehand.init()

# Access session details
print(f"Session ID: {stagehand.session_id}")
print(f"Session URL: https://app.browserbase.com/sessions/{stagehand.session_id}")

# Retrieve session information via API
response = requests.get(
    f"https://api.browserbase.com/v1/sessions/{stagehand.session_id}",
    headers={
        "X-BB-API-Key": os.getenv("BROWSERBASE_API_KEY"),
    }
)

session_info = response.json()
print(f"Session status: {session_info['status']}")
print(f"Session region: {session_info['region']}")
print(f"CPU usage: {session_info['avgCpuUsage']}")
print(f"Memory usage: {session_info['memoryUsage']}")
print(f"Proxy bytes: {session_info['proxyBytes']}")
```
</CodeGroup>

### Session Analytics & Insights

**Real-Time Monitoring**
- Live session status tracking with automatic updates
- Resource utilization metrics (CPU, memory, network)
- Geographic distribution across regions
- Concurrent session management and scaling

**Session Recordings & Replay**
- Complete session recordings for post-execution analysis
- Frame-by-frame inspection of automation steps
- Network request waterfall and timing analysis
- Visual debugging with browser interaction replay

**API-Driven Session Management**
- Programmatic access to session data and metrics
- Automated session lifecycle management
- Custom metadata tracking and filtering
- Integration with monitoring and alerting systems

<CodeGroup>
```typescript TypeScript
// Monitor session performance with analytics tracking
const stagehand = new Stagehand({
  env: "BROWSERBASE",
  apiKey: process.env.BROWSERBASE_API_KEY,
  projectId: process.env.BROWSERBASE_PROJECT_ID,
});

// Initialize and track session metrics
await stagehand.init();
console.log(`Session started: ${stagehand.sessionId}`);
console.log(`Monitor at: https://app.browserbase.com/sessions/${stagehand.sessionId}`);

// Track automation performance
const startTime = Date.now();
// ... perform automation tasks
const metrics = stagehand.metrics;
console.log('Session Performance:', {
  totalTokens: metrics.totalPromptTokens + metrics.totalCompletionTokens,
  totalTime: Date.now() - startTime,
  sessionUrl: `https://app.browserbase.com/sessions/${stagehand.sessionId}`
});
```

```python Python
# Monitor session performance with analytics tracking
stagehand = Stagehand(
    env="BROWSERBASE",
    api_key=os.getenv("BROWSERBASE_API_KEY"),
    project_id=os.getenv("BROWSERBASE_PROJECT_ID"),
)

# Initialize and track session metrics
await stagehand.init()
print(f"Session started: {stagehand.session_id}")
print(f"Monitor at: https://app.browserbase.com/sessions/{stagehand.session_id}")

# Track automation performance
import time
start_time = time.time()
# ... perform automation tasks
metrics = stagehand.metrics
print('Session Performance:', {
    'total_tokens': metrics['total_prompt_tokens'] + metrics['total_completion_tokens'],
    'total_time': (time.time() - start_time) * 1000,
    'session_url': f"https://app.browserbase.com/sessions/{stagehand.session_id}"
})
```
</CodeGroup>

### Session Monitoring & Filtering

Query and monitor sessions by status and metadata:

<CodeGroup>
```typescript TypeScript
// List sessions with filtering
async function getFilteredSessions() {
  const response = await fetch('https://api.browserbase.com/v1/sessions?status=RUNNING', {
    headers: {
      'X-BB-API-Key': process.env.BROWSERBASE_API_KEY,
    }
  });
  
  const sessions = await response.json();
  
  return sessions.map(session => ({
    id: session.id,
    status: session.status, // RUNNING, COMPLETED, ERROR, TIMED_OUT
    startedAt: session.startedAt,
    endedAt: session.endedAt,
    region: session.region,
    avgCpuUsage: session.avgCpuUsage,
    memoryUsage: session.memoryUsage,
    proxyBytes: session.proxyBytes,
    userMetadata: session.userMetadata
  }));
}

// Query sessions by metadata
async function querySessionsByMetadata(query: string) {
  const response = await fetch(`https://api.browserbase.com/v1/sessions?q=${encodeURIComponent(query)}`, {
    headers: {
      'X-BB-API-Key': process.env.BROWSERBASE_API_KEY,
    }
  });
  
  return response.json();
}
```

```python Python
import requests
import urllib.parse

def get_filtered_sessions():
    response = requests.get(
        "https://api.browserbase.com/v1/sessions",
        params={"status": "RUNNING"},
        headers={"X-BB-API-Key": os.getenv("BROWSERBASE_API_KEY")}
    )
    
    sessions = response.json()
    
    return [{
        'id': session['id'],
        'status': session['status'],  # RUNNING, COMPLETED, ERROR, TIMED_OUT
        'started_at': session['startedAt'],
        'ended_at': session['endedAt'],
        'region': session['region'],
        'avg_cpu_usage': session['avgCpuUsage'],
        'memory_usage': session['memoryUsage'],
        'proxy_bytes': session['proxyBytes'],
        'user_metadata': session['userMetadata']
    } for session in sessions]

def query_sessions_by_metadata(query):
    response = requests.get(
        "https://api.browserbase.com/v1/sessions",
        params={"q": query},
        headers={"X-BB-API-Key": os.getenv("BROWSERBASE_API_KEY")}
    )
    
    return response.json()
```
</CodeGroup>

### Session Analytics

Track automation performance and resource usage:

<CodeGroup>
```typescript TypeScript
// Get comprehensive session analytics
async function getSessionAnalytics(sessionId: string) {
  const response = await fetch(`https://api.browserbase.com/v1/sessions/${sessionId}`, {
    headers: {
      'X-BB-API-Key': process.env.BROWSERBASE_API_KEY,
    }
  });
  
  const session = await response.json();
  
  return {
    id: session.id,
    status: session.status,
    duration: session.endedAt ? 
      new Date(session.endedAt).getTime() - new Date(session.startedAt).getTime() : null,
    region: session.region,
    avgCpuUsage: session.avgCpuUsage,
    memoryUsage: session.memoryUsage,
    proxyBytes: session.proxyBytes,
    keepAlive: session.keepAlive,
    connectUrl: session.connectUrl,
    userMetadata: session.userMetadata
  };
}
```

```python Python
from datetime import datetime

def get_session_analytics(session_id):
    response = requests.get(
        f"https://api.browserbase.com/v1/sessions/{session_id}",
        headers={"X-BB-API-Key": os.getenv("BROWSERBASE_API_KEY")}
    )
    
    session = response.json()
    
    # Calculate duration if session is completed
    duration = None
    if session.get('endedAt') and session.get('startedAt'):
        start = datetime.fromisoformat(session['startedAt'].replace('Z', '+00:00'))
        end = datetime.fromisoformat(session['endedAt'].replace('Z', '+00:00'))
        duration = int((end - start).total_seconds() * 1000)  # milliseconds
    
    return {
        'id': session['id'],
        'status': session['status'],
        'duration': duration,
        'region': session['region'],
        'avg_cpu_usage': session['avgCpuUsage'],
        'memory_usage': session['memoryUsage'],
        'proxy_bytes': session['proxyBytes'],
        'keep_alive': session['keepAlive'],
        'connect_url': session['connectUrl'],
        'user_metadata': session['userMetadata']
    }
```
</CodeGroup>

## Local Environment Monitoring

For local development, Stagehand provides performance monitoring and resource tracking capabilities directly on your machine.

### Local Performance Tracking

<CodeGroup>
```typescript TypeScript
import { Stagehand } from "@browserbase/stagehand";

const stagehand = new Stagehand({
  env: "LOCAL",
  verbose: 1, // Monitor performance without debug noise
});

// Track local automation metrics
const startTime = Date.now();
const initialMetrics = stagehand.metrics;

// ... perform automation tasks

const finalMetrics = stagehand.metrics;
const executionTime = Date.now() - startTime;

console.log('Local Performance Summary:', {
  executionTime: `${executionTime}ms`,
  totalTokens: finalMetrics.totalPromptTokens + finalMetrics.totalCompletionTokens,
  averageResponseTime: finalMetrics.totalInferenceTimeMs / 3, // Assuming 3 operations
  tokensPerSecond: (finalMetrics.totalPromptTokens + finalMetrics.totalCompletionTokens) / (executionTime / 1000)
});
```

```python Python
from stagehand import Stagehand
import time

stagehand = Stagehand(
    env="LOCAL",
    verbose=1,  # Monitor performance without debug noise
)

# Track local automation metrics
start_time = time.time()
initial_metrics = stagehand.metrics

# ... perform automation tasks

final_metrics = stagehand.metrics
execution_time = (time.time() - start_time) * 1000  # Convert to ms

print('Local Performance Summary:', {
    'execution_time': f"{execution_time:.0f}ms",
    'total_tokens': final_metrics['total_prompt_tokens'] + final_metrics['total_completion_tokens'],
    'average_response_time': final_metrics['total_inference_time_ms'] / 3,  # Assuming 3 operations
    'tokens_per_second': (final_metrics['total_prompt_tokens'] + final_metrics['total_completion_tokens']) / (execution_time / 1000)
})
```
</CodeGroup>

### Resource Usage Monitoring

When running locally, monitor system resource usage and browser performance:

<CodeGroup>
```typescript TypeScript
import { Stagehand } from "@browserbase/stagehand";
import * as os from 'os';
import { performance } from 'perf_hooks';

class LocalResourceMonitor {
  private cpuUsage: number[] = [];
  private memoryUsage: number[] = [];
  
  startMonitoring() {
    const interval = setInterval(() => {
      // Track system resources
      const memUsage = process.memoryUsage();
      this.memoryUsage.push(memUsage.heapUsed / 1024 / 1024); // MB
      
      // Track CPU (simplified)
      const loadAvg = os.loadavg()[0];
      this.cpuUsage.push(loadAvg);
    }, 1000);
    
    return interval;
  }
  
  getResourceSummary() {
    return {
      avgMemoryUsage: this.memoryUsage.reduce((a, b) => a + b, 0) / this.memoryUsage.length,
      peakMemoryUsage: Math.max(...this.memoryUsage),
      avgCpuLoad: this.cpuUsage.reduce((a, b) => a + b, 0) / this.cpuUsage.length,
      totalDataPoints: this.cpuUsage.length
    };
  }
}

const monitor = new LocalResourceMonitor();
const interval = monitor.startMonitoring();

const stagehand = new Stagehand({ env: "LOCAL" });

// ... run automation

clearInterval(interval);
console.log('Resource Usage:', monitor.getResourceSummary());
```

```python Python
import psutil
import time
from typing import List
from stagehand import Stagehand

class LocalResourceMonitor:
    def __init__(self):
        self.cpu_usage: List[float] = []
        self.memory_usage: List[float] = []
        self.monitoring = False
    
    def start_monitoring(self):
        self.monitoring = True
        import threading
        
        def monitor_resources():
            while self.monitoring:
                # Track CPU and memory usage
                cpu_percent = psutil.cpu_percent(interval=1)
                memory_info = psutil.virtual_memory()
                
                self.cpu_usage.append(cpu_percent)
                self.memory_usage.append(memory_info.percent)
                
                time.sleep(1)
        
        thread = threading.Thread(target=monitor_resources)
        thread.daemon = True
        thread.start()
        return thread
    
    def stop_monitoring(self):
        self.monitoring = False
    
    def get_resource_summary(self):
        if not self.cpu_usage or not self.memory_usage:
            return {'error': 'No monitoring data collected'}
        
        return {
            'avg_cpu_usage': sum(self.cpu_usage) / len(self.cpu_usage),
            'peak_cpu_usage': max(self.cpu_usage),
            'avg_memory_usage': sum(self.memory_usage) / len(self.memory_usage),
            'peak_memory_usage': max(self.memory_usage),
            'total_data_points': len(self.cpu_usage)
        }

monitor = LocalResourceMonitor()
monitor.start_monitoring()

stagehand = Stagehand(env="LOCAL")

# ... run automation

monitor.stop_monitoring()
print('Resource Usage:', monitor.get_resource_summary())
```
</CodeGroup>

### Automation Metrics Comparison

Compare performance between different automation approaches:

<CodeGroup>
```typescript TypeScript
class LocalPerformanceMonitor {
  private actionTimes: Map<string, number> = new Map();
  private startTimes: Map<string, number> = new Map();
  
  logActionStart(action: string) {
    this.startTimes.set(action, Date.now());
  }
  
  logActionEnd(action: string) {
    const startTime = this.startTimes.get(action);
    if (startTime) {
      const duration = Date.now() - startTime;
      this.actionTimes.set(action, duration);
      console.log(`⏱️ ${action} completed in ${duration}ms`);
    }
  }
  
  getPerformanceReport() {
    const report = Array.from(this.actionTimes.entries()).map(([action, time]) => ({
      action,
      duration: time,
      slow: time > 5000
    }));
    
    return report.sort((a, b) => b.duration - a.duration);
  }
}

const monitor = new LocalPerformanceMonitor();

const stagehand = new Stagehand({
  env: "LOCAL",
  logger: (logLine) => {
    console.log(`[${logLine.category}] ${logLine.message}`);
    
    // Track action performance
    if (logLine.category === 'action' && logLine.auxiliary?.executionTime) {
      const duration = parseFloat(logLine.auxiliary.executionTime.value);
      console.log(`⏱️ Action duration: ${duration}ms`);
    }
  }
});
```

```python Python
import time
from typing import Dict, List

class LocalPerformanceMonitor:
    def __init__(self):
        self.action_times: Dict[str, float] = {}
        self.start_times: Dict[str, float] = {}
    
    def log_action_start(self, action: str):
        self.start_times[action] = time.time() * 1000
    
    def log_action_end(self, action: str):
        start_time = self.start_times.get(action)
        if start_time:
            duration = time.time() * 1000 - start_time
            self.action_times[action] = duration
            print(f"⏱️ {action} completed in {duration:.0f}ms")
    
    def get_performance_report(self) -> List[Dict]:
        report = [
            {
                'action': action,
                'duration': time,
                'slow': time > 5000
            }
            for action, time in self.action_times.items()
        ]
        return sorted(report, key=lambda x: x['duration'], reverse=True)

monitor = LocalPerformanceMonitor()

def performance_logger(log_line):
    print(f"[{log_line.get('category')}] {log_line.get('message')}")
    
    # Track action performance
    if (log_line.get('category') == 'action' and 
        log_line.get('auxiliary', {}).get('executionTime')):
        duration = float(log_line['auxiliary']['executionTime']['value'])
        print(f"⏱️ Action duration: {duration:.0f}ms")

stagehand = Stagehand(
    env="LOCAL",
    logger=performance_logger
)
```
</CodeGroup>

## Monitoring Best Practices

### Production Monitoring
- Track session success rates and failure patterns
- Monitor resource usage and scaling requirements
- Set up automated alerting for critical failures
- Implement cost tracking across different environments
- Use session analytics to optimize automation workflows

### Performance Optimization
- Compare Browserbase vs local execution times
- Monitor token usage and inference costs across models
- Track geographic performance differences
- Identify bottlenecks in automation workflows
- Optimize for cost-effectiveness and speed

### Operational Insights
- Track session distribution across regions
- Monitor concurrent session limits and scaling
- Analyze failure patterns and common error scenarios
- Use session recordings for root cause analysis
- Implement custom metadata for workflow categorization

### Integration & Alerting
- Integrate session APIs with monitoring dashboards
- Set up automated notifications for session failures  
- Track SLA compliance and performance benchmarks
- Monitor resource costs and usage patterns
- Use analytics data for capacity planning and optimization

For detailed logging and debugging capabilities, see [Logging](/configuration/logging).