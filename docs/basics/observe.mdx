---
title: Observe
sidebarTitle: Observe
description: 'Find suggested actions for your workflows'
---

## What is `observe()`?

`observe` is Stagehand's intelligence layer that discovers actionable elements on web pages and suggests optimal actions. Instead of blindly attempting actions, observe first to understand what's possible, plan multi-step workflows, and build resilient automation.

``` typescript
await page.observe("Find the login button")
```

## Why Use Observe?

<CardGroup cols={2}>
  <Card title="Explore" icon="compass">
    When you're unsure what's on a page or need to discover available actions
  </Card>
  <Card title="Plan" icon="map">
    When building complex workflows, plan ahead all the actions you'll need to take
  </Card>
  <Card title="Cache" icon="database">
    When you want to remember actions for the future and avoid LLM calls
  </Card>
    <Card title="Validate" icon="check">
    Before performing critical actions to ensure elements exist
  </Card>
</CardGroup>

## Core Concepts

### Integration with Stagehand Methods

`observe` augments what you can do with other Stagehand methods:

#### Observe → Act
<CodeGroup>
```typescript TypeScript
// Observe → Act workflow 
const buttons = await page.observe("Find submit buttons");
await page.act(buttons[0]); // Fast execution, no LLM inference with self healing

// Direct act (slower, requires LLM inference)  
await page.act("Click the submit button");
```
```python Python
# Observe → Act workflow 
buttons = await page.observe("Find submit buttons")
await page.act(buttons[0]) # Fast execution, no LLM inference with self healing

# Direct act (slower, requires LLM inference)  
await page.act("Click the submit button")
```
</CodeGroup>
<Note>
**Performance Tip**: Pass `ObserveResult` objects directly to `act()` to skip LLM inference and execute actions immediately. This can reduce automation time by 2-3x for known actions. To avoid script maintenance, check out [self healing](/basics/act/self-healing) for more details.
</Note>

#### Observe → Extract

<CodeGroup>
```typescript TypeScript
// Use observe to validate elements before extraction
const tableElements = await page.observe("Find data tables");

if (tableElements.length > 0) {
  const data = await page.extract({
    instruction: "Extract product information from the table",
    schema: { products: [{ name: "string", price: "number" }] },
    selector: tableElements[0].selector // Optional, but recommended for reduced LLM token usage
  });
}
```
```python Python
# Use observe to validate elements before extraction
table_elements = await page.observe("Find data tables")

if len(table_elements) > 0:
  data = await page.extract({
    instruction: "Extract product information from the table",
    schema: { products: [{ name: "string", price: "number" }] },
    selector: table_elements[0].selector # Optional, but recommended for reduced LLM token usage
  })
```
</CodeGroup>
<Tip>
**Savings Tip**: Pass the selector to `extract()` to have the LLM focus on a specific section of the page (like a table, a form, a list...) to minimize the context needed for an extraction. This can reduce LLM token usage by 10x for verbose websites!
</Tip>

### Suggested Actions - Previews

Each observation returns detailed information about actionable elements:

```json
{
  "selector": "xpath=/html/body/div[1]/form/button[1]",
  "description": "Submit button for contact form",
  "method": "click",
  "arguments": []
}
```

<AccordionGroup>
<Accordion title="selector">
**XPath selector** to precisely locate the element on the page. This ensures reliable element targeting even when page layouts change.
</Accordion>

<Accordion title="description">
**Human-readable description** of what the element is and its purpose. Helps with debugging and workflow understanding.
</Accordion>

<Accordion title="method">
**Suggested action method** such as `click`, `type`, `hover`, or `select`. Based on element type and common interaction patterns.
</Accordion>

<Accordion title="arguments">
**Additional parameters** required for the action. Usually empty for simple actions like clicks, but may contain values for complex interactions.
</Accordion>
</AccordionGroup>


## Best Practices

### When to Use Observe

<CardGroup cols={2}>
  <Card title="✅ Use Observe When">
    <ul>
      <li><strong>Exploring unknown pages</strong> – Understanding available actions</li>
      <li><strong>Building complex workflows</strong> – Planning multi-step automation</li>
      <li><strong>Error recovery</strong> – Finding alternatives when actions fail</li>
      <li><strong>Performance optimization</strong> – Caching actions to reduce LLM calls</li>
      <li><strong>Conditional logic</strong> – Making decisions based on page state</li>
      <li><strong>Quality assurance</strong> – Validating elements exist before acting</li>
    </ul>
  </Card>
  <Card title="❌ Avoid Observe When">
    <ul>
      <li><strong>Simple, known actions</strong> – Direct <code>act()</code> is faster for obvious elements</li>
      <li><strong>Real-time interactions</strong> – Chat systems, live updates where speed matters</li>
      <li><strong>Static workflows</strong> – Same actions on identical pages every time</li>
      <li><strong>Cost-sensitive operations</strong> – When minimizing LLM calls is critical</li>
      <li><strong>Simple boolean checks</strong> – Use targeted <code>extract()</code> for true/false queries</li>
    </ul>
  </Card>
</CardGroup>

### Optimization Guidelines

1. **Cache Intelligently**: Store observations for reuse on similar page types
2. **Batch Requests**: Combine multiple requirements into single observations  
3. **Choose Models Wisely**: Use faster models for simple observations
4. **Scope Instructions**: Be specific to reduce analysis time and cost
5. **Handle Errors Gracefully**: Always check observation results before acting
6. **Monitor Performance**: Track observation speed and accuracy over time

## Troubleshooting

<AccordionGroup>
<Accordion title="No elements found">
**Problem**: `observe()` returns empty array

**Solutions**:
- Ensure page has fully loaded: `await page.waitForLoadState('networkidle')`
- Increase DOM settle timeout: `domSettleTimeoutMs: 60000`
- Check if content is in iframes: `iframes: true`
- Make instructions more general: "Find any interactive elements"

```typescript
// Debug empty results
const observations = await page.observe({
  instruction: "Find any clickable elements, buttons, or links",
  domSettleTimeoutMs: 45000,
  iframes: true
});

if (observations.length === 0) {
  console.log("Page HTML:", await page.content());
}
```
</Accordion>

<Accordion title="Inaccurate element descriptions">
**Problem**: Descriptions don't match actual elements

**Solutions**:
- Use more capable models: `modelName: "anthropic/claude-3-7-sonnet-latest"`
- Provide more specific instructions
- Set deterministic model behavior: `modelClientOptions: { temperature: 0 }`
- Take screenshots for debugging

```typescript
const observations = await page.observe({
  instruction: "Find the main call-to-action button on this e-commerce product page",
  modelName: "gpt-4o", // More accurate model
  modelClientOptions: { temperature: 0 } // Deterministic
});
```
</Accordion>

<Accordion title="Slow performance">
**Problem**: `observe()` takes too long

**Solutions**:
- Use faster models: `modelName: "google/gemini-2.0-flash"`
- Be more specific with instructions to reduce analysis scope
- Cache observations for similar pages
- Reduce DOM settle timeout if appropriate

```typescript
// Optimized for speed
const observations = await page.observe({
  instruction: "Find only the most important buttons", // Specific scope
  modelName: "google/gemini-2.0-flash", // Fast model
  domSettleTimeoutMs: 15000 // Shorter timeout
});
```
</Accordion>

<Accordion title="High costs from too many LLM calls">
**Problem**: Frequent observations causing high token usage

**Solutions**:
- Implement caching for similar page types
- Batch multiple requirements into single observation
- Use cheaper models for simple observations
- Cache and reuse ObserveResults

```typescript
// Cost-optimized observation
const cachedObservations = actionCache.get(pageType);
if (cachedObservations) return cachedObservations;

const observations = await page.observe({
  instruction: "Find navigation, forms, buttons, and key content areas", // Batch request
  modelName: "google/gemini-2.0-flash" // Cost-effective model
});

actionCache.set(pageType, observations);
```
</Accordion>
</AccordionGroup>


## Next Steps

<CardGroup cols={2}>
<Card title="Act Overview" icon="play" href="/basics/act/overview">
Execute actions efficiently using observe results
</Card>

<Card title="Extract Data" icon="download" href="/basics/extract/overview">  
Extract structured data from observed elements
</Card>

<Card title="Observability" icon="chart-line" href="/configuration/observability">
Monitor and debug observation performance  
</Card>

<Card title="Best Practices" icon="star" href="/best_practices/best_practices">
Advanced patterns and optimization techniques
</Card>
</CardGroup>