---
title: Observe
sidebarTitle: Observe
description: 'Find suggested actions for your workflows'
---

## What is `observe()`?
``` typescript
await page.observe("Find the login button")
```

Calling `observe` turns any page into a checklist of reliable, executable actions. It discovers key elements, ranks likely next steps, and returns structured actions (selector, method, args) you can run instantly with `act` or use to precisely target `extract`—so workflows are faster, cheaper, and more resilient.

## Why use `observe`?

<CardGroup cols={2}>
  <Card title="Explore" icon="compass" href="/basics/observe#observe-with-act">
    When you're unsure what's on a page or need to discover available actions
  </Card>
  <Card title="Plan" icon="map" href="/basics/observe#observe-with-act">
    When building complex workflows, plan ahead all the actions you'll need to take
  </Card>
  <Card title="Cache" icon="database" href="/basics/observe#determine-your-automation">
    When you want to remember actions for the future and avoid LLM calls
  </Card>
    <Card title="Validate" icon="check" href="/basics/observe#observe-with-act">
    Before performing critical actions to ensure elements exist
  </Card>
</CardGroup>

## Using `observe()`

Calling `observe` supercharges other Stagehand methods. Use it to plan workflows, speed up `act`, and precisely target `extract`.

### Observe with Act

Using `observe` to plan workflows is a great way to speed up `act`. For example, you can ask `observe` to find all the fields in a form and then use `act` to fill them in one by one without added LLM inference.

<Note>
**Performance Tip**: Acting on multiple `observe` suggestions will minimize the number of LLM calls for multi-step actions and speed up your workflow 2-3x.
</Note>

<CodeGroup>
```typescript TypeScript
// Plan & validate
const buttons = await page.observe("Find the log in / sign up buttons");
```
```python Python
# Plan & validate
buttons = await page.observe("Find the log in / sign up buttons")
```
</CodeGroup>

This will return a list of suggestions with the following structure
```json
{
  "selector": "xpath=/html/body/header/div/button[1]",
  "description": "Log in button in the top right corner",
  "method": "click",
  "arguments": []
}
```
You can validate the action (method, selector, arguments...) and then pass it to `act` to avoid extra LLM inference

<CodeGroup>
```typescript TypeScript
await page.act(buttons[0]); // No LLM!
```
```python Python
await page.act(buttons[0]) # No LLM!
```
</CodeGroup>

### Observe and Extract

Using `observe` to focus `extract` on a specific section of the page (like a table, a form, a list...) minimizes the context needed for an extraction. 
<Tip>
**Savings Tip**: Pass the selector to `extract` to reduce LLM token usage by 10x for verbose websites!
</Tip>

<CodeGroup>
```typescript TypeScript
// Use observe to validate elements before extraction
const tableElements = await page.observe("Find data tables");

if (tableElements.length > 0) {
  const data = await page.extract({
    instruction: "Extract product information from the table",
    schema: { products: [{ name: "string", price: "number" }] },
    selector: tableElements[0].selector // Optional, but recommended for reduced LLM token usage
  });
}
```
```python Python
# Use observe to validate elements before extraction
table_elements = await page.observe("Find data tables")

if len(table_elements) > 0:
  data = await page.extract({
    instruction: "Extract product information from the table",
    schema: { products: [{ name: "string", price: "number" }] },
    selector: table_elements[0].selector # Optional, but recommended for reduced LLM token usage
  })
```
</CodeGroup>


### Determine your automation

Each observation returns detailed information about actionable elements:

```json
{
  "selector": "xpath=/html/body/div[1]/form/button[1]",
  "description": "Submit button for contact form",
  "method": "click",
  "arguments": []
}
```

- **selector**: XPath to precisely locate the element for reliable targeting
- **description**: Summary of the element and its purpose
- **method**: Suggested action such as `click`, `type`, `hover`, or `select` (check out [supported actions](/basics/act/overview))
- **arguments**: Extra parameters when needed; usually empty for simple clicks


## Best Practices

### When to Use Observe

<CardGroup cols={2}>
  <Card title="✅ Use Observe When">
    <ul>
      <li><strong>Exploring unknown pages</strong> – Understanding available actions</li>
      <li><strong>Building complex workflows</strong> – Planning multi-step automation</li>
      <li><strong>Error recovery</strong> – Finding alternatives when actions fail</li>
      <li><strong>Performance optimization</strong> – Caching actions to reduce LLM calls</li>
      <li><strong>Conditional logic</strong> – Making decisions based on page state</li>
      <li><strong>Quality assurance</strong> – Validating elements exist before acting</li>
    </ul>
  </Card>
  <Card title="❌ Avoid Observe When">
    <ul>
      <li><strong>Simple, known actions</strong> – Direct <code>act()</code> is faster for obvious elements</li>
      <li><strong>Real-time interactions</strong> – Chat systems, live updates where speed matters</li>
      <li><strong>Static workflows</strong> – Same actions on identical pages every time</li>
      <li><strong>Cost-sensitive operations</strong> – When minimizing LLM calls is critical</li>
      <li><strong>Simple boolean checks</strong> – Use targeted <code>extract()</code> for true/false queries</li>
    </ul>
  </Card>
</CardGroup>

### Optimization Guidelines

1. **Cache Intelligently**: Store observations for reuse on similar page types
2. **Batch Requests**: Combine multiple requirements into single observations  
3. **Choose Models Wisely**: Use faster models for simple observations
4. **Scope Instructions**: Be specific to reduce analysis time and cost
5. **Handle Errors Gracefully**: Always check observation results before acting
6. **Monitor Performance**: Track observation speed and accuracy over time

## Troubleshooting

<AccordionGroup>
<Accordion title="No elements found">
**Problem**: `observe()` returns empty array

**Solutions**:
- Make sure the element exists on the page
- Use explicit instructions to find the element
- Ensure page has fully loaded: `await page.waitForLoadState('networkidle')`
- Increase DOM settle timeout: `domSettleTimeoutMs: 60000`
- Check if content is in iframes: `iframes: true`
- Look at the [debugging](/basics/debugging) logs, if the element is there then the LLM might be hallucinating/not catching it. 

```typescript
// Debug empty results
const observations = await page.observe({
  instruction: "Find any clickable elements, buttons, or links",
  domSettleTimeoutMs: 45000,
  iframes: true
});

if (observations.length === 0) {
  console.log("Page HTML:", await page.content());
}
```
</Accordion>

<Accordion title="Inaccurate element descriptions">
**Problem**: Descriptions don't match actual elements

**Solutions**:
- Use more capable models: `modelName: "anthropic/claude-3-7-sonnet-latest"`
- Provide more specific instructions
- Set deterministic model behavior: `modelClientOptions: { temperature: 0 }`
- Take screenshots for debugging

```typescript
const observations = await page.observe({
  instruction: "Find the main call-to-action button on this e-commerce product page",
  modelName: "gpt-4o", // More accurate model
  modelClientOptions: { temperature: 0 } // Deterministic
});
```
</Accordion>

<Accordion title="Slow performance">
**Problem**: `observe()` takes too long

**Solutions**:
- Use faster models: `modelName: "google/gemini-2.0-flash"`
- Be more specific with instructions to reduce analysis scope
- Cache observations for similar pages
- Reduce DOM settle timeout if appropriate

```typescript
// Optimized for speed
const observations = await page.observe({
  instruction: "Find only the most important buttons", // Specific scope
  modelName: "google/gemini-2.0-flash", // Fast model
  domSettleTimeoutMs: 15000 // Shorter timeout
});
```
</Accordion>

<Accordion title="High costs from too many LLM calls">
**Problem**: Frequent observations causing high token usage

**Solutions**:
- Implement caching for similar page types
- Batch multiple requirements into single observation
- Use cheaper models for simple observations
- Cache and reuse ObserveResults

```typescript
// Cost-optimized observation
const cachedObservations = actionCache.get(pageType);
if (cachedObservations) return cachedObservations;

const observations = await page.observe({
  instruction: "Find navigation, forms, buttons, and key content areas", // Batch request
  modelName: "google/gemini-2.0-flash" // Cost-effective model
});

actionCache.set(pageType, observations);
```
</Accordion>
</AccordionGroup>


## Next Steps

<CardGroup cols={2}>
<Card title="Act Overview" icon="play" href="/basics/act/overview">
Execute actions efficiently using observe results
</Card>

<Card title="Extract Data" icon="download" href="/basics/extract/overview">  
Extract structured data from observed elements
</Card>

<Card title="Observability" icon="chart-line" href="/configuration/observability">
Monitor and debug observation performance  
</Card>

<Card title="Best Practices" icon="star" href="/best_practices/best_practices">
Advanced patterns and optimization techniques
</Card>
</CardGroup>