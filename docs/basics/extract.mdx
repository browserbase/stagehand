---
title: Extract
---

## What is `extract()`?
The `extract` method grabs structured data from a webpage. You can define your schema with [zod](https://github.com/colinhacks/zod) (TypeScript) or [pydantic](https://github.com/pydantic/pydantic) (Python). If you do not want to define a schema, you can also call `extract` with just a [natural language prompt](#extract-with-just-a-prompt), or call `extract` [with no parameters](#extract-with-no-parameters).

<Note>
For TypeScript, the extract schemas are defined using zod schemas.

For Python, the extract schemas are defined using pydantic models.
</Note>

### Extract a single object

Here is how an `extract` call might look for a single object:

<CodeGroup>
```typescript TypeScript
const item = await page.extract({
  instruction: "extract the price of the item",
  schema: z.object({
    price: z.number(),
  }),
});
```

```python Python
class Extraction(BaseModel):
    price: float

item = await page.extract(
    "extract the price of the item", 
    schema=Extraction
)
```
</CodeGroup>

Your output schema will look like:
```JSON JSON
{ price: number }
```

### Extract a link
<Note>
To extract links or URLs, in the TypeScript version of Stagehand, you'll need to define the relevant field as `z.string().url()`.
In Python, you'll need to define it as `HttpUrl`.
</Note>

Here is how an `extract` call might look for extracting a link or URL. This also works for image links.

<CodeGroup>
```typescript TypeScript
const extraction = await page.extract({
  instruction: "extract the link to the 'contact us' page",
  schema: z.object({
    link: z.string().url(), // note the usage of z.string().url() here
  }),
});

console.log("the link to the contact us page is: ", extraction.link);
```

```python Python
class Extraction(BaseModel):
    link: HttpUrl # note the usage of HttpUrl here

extraction = await page.extract(
    "extract the link to the 'contact us' page", 
    schema=Extraction
)

print("the link to the contact us page is: ", extraction.link)
```
</CodeGroup>

<Tip>
Inside Stagehand, extracting links works by asking the LLM to select an ID. Stagehand looks up that ID in a mapping of IDs -> URLs. When logging the LLM trace, you should expect to see IDs. The actual URLs will be included in the final `ExtractResult`.
</Tip>

### Extract a list of objects

Here is how an `extract` call might look for a list of objects.

<CodeGroup>
```typescript TypeScript
const apartments = await page.extract({
  instruction:
    "Extract ALL the apartment listings and their details, including address, price, and square feet."
  schema: z.object({
    list_of_apartments: z.array(
      z.object({
        address: z.string(),
        price: z.string(),
        square_feet: z.string(),
      }),
    ),
  })
})

console.log("the apartment list is: ", apartments);
```

```python Python
class Apartment(BaseModel):
    address: str
    price: str
    square_feet: str

class Apartments(BaseModel):
    list_of_apartments: list[Apartment]

apartments = await page.extract(
    "Extract ALL the apartment listings and their details as a list, including address, price, and square feet for each apartment",
    schema=Apartments
)

print("the apartment list is: ", apartments)
```
</CodeGroup>

Your output schema will look like:
```JSON JSON
list_of_apartments: [
    {
      address: "street address here",
      price: "$1234.00",
      square_feet: "700"
    },
    {
        address: "another address here",
        price: "1010.00",
        square_feet: "500"
    },
    ...
]
```


### Extract with additional context

You can provide additional context to your schema to help the model extract the data more accurately.

<CodeGroup>
```typescript TypeScript
const apartments = await page.extract({
 instruction:
   "Extract ALL the apartment listings and their details, including address, price, and square feet."
 schema: z.object({
   list_of_apartments: z.array(
     z.object({
       address: z.string().describe("the address of the apartment"),
       price: z.string().describe("the price of the apartment"),
       square_feet: z.string().describe("the square footage of the apartment"),
     }),
   ),
 })
})
```

```python Python
class Apartment(BaseModel):
    address: str = Field(..., description="the address of the apartment")
    price: str = Field(..., description="the price of the apartment")
    square_feet: str = Field(..., description="the square footage of the apartment")

class Apartments(BaseModel):
    list_of_apartments: list[Apartment]

apartments = await page.extract(
    "Extract ALL the apartment listings and their details as a list. For each apartment, include: the address of the apartment, the price of the apartment, and the square footage of the apartment",
    schema=Apartments
)
```
</CodeGroup>

### Extract with just a prompt

You can call `extract` with just a natural language prompt:

<CodeGroup>
```typescript TypeScript
const result = await page.extract("extract the name of the repository");
```

```python Python
result = await page.extract("extract the name of the repository")
```
</CodeGroup>

When you call `extract` with just a prompt, your output schema will look like:
```JSON JSON
{ extraction: string }
```


### Extract with no parameters

Calling `extract` with no parameters will return hierarchical tree representation of the root DOM. This will not be passed through an LLM. It will look something like this:

```
Accessibility Tree:
[0-2] RootWebArea: What is Stagehand? - ðŸ¤˜ Stagehand
  [0-37] scrollable
    [0-118] body
      [0-241] scrollable
        [0-242] div
          [0-244] link: ðŸ¤˜ Stagehand home page light logo
            [0-245] span
              [0-246] StaticText: ðŸ¤˜ Stagehand
              [0-247] StaticText: home page
```

Here is how you can call `extract` with no parameters
<CodeGroup>
```typescript TypeScript
const pageText = await page.extract();
```

```python Python
page_text = await page.extract()
```
</CodeGroup>

Your output schema will look like:
```JSON JSON
{ page_text: string }
```
