---
title: 提取
description: 从网页提取结构化数据
---

<div id="what-is-extract">
  ## 什么是 `extract()`？
</div>

```typescript
page.extract("extract the name of the repository");
```

`extract` 用于从网页中提取结构化数据。你可以使用 [zod](https://github.com/colinhacks/zod)（TypeScript）或 [pydantic](https://github.com/pydantic/pydantic)（Python）来定义 schema。如果不想定义 schema，也可以只用[自然语言提示](#extract-with-just-a-prompt)来调用 `extract`，或[不传任何参数](#extract-with-no-parameters)直接调用 `extract`。

<div id="why-use-extract">
  ## 为什么使用 `extract()`？
</div>

<CardGroup cols={2}>
  <Card title="结构化" icon="brackets-curly" href="#list-of-objects-extraction">
    将杂乱的网页数据转换为符合架构的干净对象。
  </Card>

  <Card title="健壮" icon="dumbbell" href="#extract-with-context">
    构建对网站变更不敏感、不会轻易失效的抽取方案。
  </Card>
</CardGroup>

<Note>
  对于 TypeScript，抽取的架构使用 zod 的 schema 定义。
  对于 Python，抽取的架构使用 pydantic 的模型定义。
</Note>

<div id="using-extract">
  ## 使用 `extract()`
</div>

<div id="single-object-extraction">
  ### 单个对象提取
</div>

以下是对单个对象进行 `extract` 调用的示例：

<CodeGroup>
  ```typescript TypeScript
  const item = await page.extract({
    instruction: "提取该商品的价格",
    schema: z.object({
      price: z.number(),
    }),
  });
  ```

  ```python Python
  class Extraction(BaseModel):
      price: float

  item = await page.extract(
      "提取该商品的价格", 
      schema=Extraction
  )
  ```
</CodeGroup>

输出模式如下：

```Example
{ price: number }
```

<div id="list-of-objects-extraction">
  ### 对象列表提取
</div>

以下是对对象列表进行 `extract` 调用的示例：

<CodeGroup>
  ```typescript TypeScript
  const apartments = await page.extract({
    instruction:
      "提取所有公寓房源及其详情，包括地址、价格和面积（平方英尺）。",
    schema: z.object({
      list_of_apartments: z.array(
        z.object({
          address: z.string(),
          price: z.string(),
          square_feet: z.string(),
        }),
      ),
    })
  })

  console.log("the apartment list is: ", apartments);
  ```

  ```python Python
  class Apartment(BaseModel):
      address: str
      price: str
      square_feet: str

  class Apartments(BaseModel):
      list_of_apartments: list[Apartment]

  apartments = await page.extract(
      "以列表形式提取所有公寓房源及其详情，包括每套公寓的地址、价格和面积（平方英尺）",
      schema=Apartments
  )

  print("the apartment list is: ", apartments)
  ```
</CodeGroup>

输出模式如下：

```Example
list_of_apartments: [
    {
      address: "street address here",
      price: "$1234.00",
      square_feet: "700"
    },
    {
        address: "another address here",
        price: "1010.00",
        square_feet: "500"
    },
    ...
]
```

<div id="prompt-only-extraction">
  ### 仅使用提示的提取
</div>

你可以仅使用自然语言提示来调用 `extract`：

<CodeGroup>
  ```typescript TypeScript
  const result = await page.extract("提取该仓库的名称");
  ```

  ```python Python
  result = await page.extract("提取该仓库的名称")
  ```
</CodeGroup>

当仅使用提示调用 `extract` 时，输出模式如下：

```Example
{ extraction: string }
```

<div id="extract-with-no-parameters">
  ### 无参数提取
</div>

以下是在没有任何参数的情况下调用 `extract` 的方法：

<CodeGroup>
  ```typescript TypeScript
  const pageText = await page.extract();
  ```

  ```python Python
  page_text = await page.extract()
  ```
</CodeGroup>

输出模式：

```Example
{ page_text: string }
```

在不传入参数的情况下调用 `extract` 将返回根 DOM 的分层树结构表示。此结果不会经过 LLM 处理。它大致如下所示：

```
Accessibility Tree:
[0-2] RootWebArea: What is Stagehand? - 🤘 Stagehand
  [0-37] scrollable
    [0-118] body
      [0-241] scrollable
        [0-242] div
          [0-244] link: 🤘 Stagehand home page light logo
            [0-245] span
              [0-246] StaticText: 🤘 Stagehand
              [0-247] StaticText: home page
```

<div id="best-practices">
  ## 最佳实践
</div>

<div id="extract-with-context">
  ### 结合上下文进行抽取
</div>

你可以为 schema 提供更多上下文，帮助模型更精准地抽取数据。

<CodeGroup>
  ```typescript TypeScript
  const apartments = await page.extract({
   instruction:
     "Extract ALL the apartment listings and their details, including address, price, and square feet.",
   schema: z.object({
     list_of_apartments: z.array(
       z.object({
         address: z.string().describe("the address of the apartment"),
         price: z.string().describe("the price of the apartment"),
         square_feet: z.string().describe("the square footage of the apartment"),
       }),
     ),
   })
  })
  ```

  ```python Python
  class Apartment(BaseModel):
      address: str = Field(..., description="the address of the apartment")
      price: str = Field(..., description="the price of the apartment")
      square_feet: str = Field(..., description="the square footage of the apartment")

  class Apartments(BaseModel):
      list_of_apartments: list[Apartment]

  apartments = await page.extract(
      "Extract ALL the apartment listings and their details as a list. For each apartment, include: the address of the apartment, the price of the apartment, and the square footage of the apartment",
      schema=Apartments
  )
  ```
</CodeGroup>

<div id="link-extraction">
  ### 链接抽取
</div>

<Note>
  要抽取链接或 URL，在 Stagehand 的 TypeScript 版本中，需要将相关字段定义为 `z.string().url()`。
  在 Python 中，需要将其定义为 `HttpUrl`。
</Note>

下面是一个用于抽取链接或 URL 的 `extract` 调用示例。对图片链接同样适用。

<CodeGroup>
  ```typescript TypeScript
  const extraction = await page.extract({
    instruction: "extract the link to the 'contact us' page",
    schema: z.object({
      link: z.string().url(), // 注意这里使用了 z.string().url()
    }),
  });

  console.log("the link to the contact us page is: ", extraction.link);
  ```

  ```python Python
  class Extraction(BaseModel):
      link: HttpUrl # 注意这里使用了 HttpUrl

  extraction = await page.extract(
      "extract the link to the 'contact us' page", 
      schema=Extraction
  )

  print("the link to the contact us page is: ", extraction.link)
  ```
</CodeGroup>

<Tip>
  在 Stagehand 内部，链接抽取的方式是让 LLM 选择一个 ID。Stagehand 会在一个 ID -> URL 的映射中查找该 ID。记录 LLM 追踪日志时，你会看到的是 ID。实际的 URL 会包含在最终的 `ExtractResult` 中。
</Tip>

<div id="troubleshooting">
  ## 故障排除
</div>

<AccordionGroup>
  <Accordion title="结果为空或不完整">
    **问题**: `extract()` 返回空或不完整的数据

    **解决方案**:

    - **检查指令是否清晰**: 确保你的指令足够具体，准确描述需要提取的数据
    - **验证数据是否存在**: 先使用 `page.observe()` 确认页面上确实存在该数据
    - **等待动态内容加载**: 如果页面以动态方式加载内容，在提取前使用 `page.act("wait for the content to load")`

    **解决方案：在提取前等待内容加载**

    <CodeGroup>
      ```typescript TypeScript
      // Wait for content before extracting
      await page.act("wait for the product listings to load");
      const products = await page.extract({
        instruction: "extract all product names and prices",
        schema: z.object({
          products: z.array(z.object({
            name: z.string(),
            price: z.string()
          }))
        })
      });
      ```

      ```python Python
      # Wait for content before extracting
      await page.act("wait for the product listings to load")
      products = await page.extract(
          "extract all product names and prices",
          schema=ProductList
      )
      ```
    </CodeGroup>
  </Accordion>

  <Accordion title="Schema 验证错误">
    **问题**: 出现 Schema 验证错误或类型不匹配

    **解决方案**:

    - **使用可选字段**: 如果数据可能并非总是存在，使用 `z.optional()`（TypeScript）或 `Optional[type]`（Python）将字段设为可选
    - **使用更灵活的类型**: 对可能包含货币符号的价格，考虑使用 `z.string()` 而不是 `z.number()`
    - **添加描述**: 使用 `.describe()`（TypeScript）或 `Field(description="...")`（Python）帮助模型理解字段要求

    **解决方案：更灵活的 Schema**

    <CodeGroup>
      ```typescript TypeScript
      const schema = z.object({
        price: z.string().describe("price including currency symbol, e.g., '$19.99'"),
        availability: z.string().optional().describe("stock status if available"),
        rating: z.number().optional()
      });
      ```

      ```python Python
      class FlexibleProduct(BaseModel):
          price: str = Field(description="price including currency symbol, e.g., '$19.99'")
          availability: Optional[str] = Field(default=None, description="stock status if available")
          rating: Optional[float] = None
      ```
    </CodeGroup>
  </Accordion>

  <Accordion title="结果不一致">
    **问题**: 不同运行之间的提取结果不一致

    **解决方案**:

    - **使指令更具体**: 例如将“extract prices”改为“extract the numerical price value for each item”
    - **在 Schema 描述中提供上下文**: 添加字段描述以引导模型
    - **配合 observe 使用**: 先用 `page.observe()` 了解页面结构

    **解决方案：先用 observe 验证**

    <CodeGroup>
      ```typescript TypeScript
      // First observe to understand the page structure
      const elements = await page.observe("find all product listings");
      console.log("Found elements:", elements.map(e => e.description));

      // Then extract with specific targeting
      const products = await page.extract({
        instruction: "extract name and price from each product listing shown on the page",
        schema: z.object({
          products: z.array(z.object({
            name: z.string().describe("the product title or name"),
            price: z.string().describe("the price as displayed, including currency")
          }))
        })
      });
      ```

      ```python Python
      # First observe to understand the page structure
      elements = await page.observe("find all product listings")
      print("Found elements:", [e.description for e in elements])

      # Then extract with specific targeting
      products = await page.extract(
          "extract name and price from each product listing shown on the page",
          schema=ProductSchema
      )
      ```
    </CodeGroup>
  </Accordion>

  <Accordion title="性能问题">
    **问题**：提取过程缓慢或出现超时

    **解决方案**：

    - **缩小范围**：通过多次调用分批提取较小的数据块，而非一次性提取全部
    - **使用针对性指令**：明确指定需要关注的页面部分
    - **考虑分页**：对于大型数据集，按页逐步提取
    - **增加超时时间**：对复杂的提取使用 `timeoutMs` 参数

    **方案：拆解大规模提取任务**

    <CodeGroup>
      ```typescript TypeScript
      // Instead of extracting everything at once
      const allData = [];
      const pageNumbers = [1, 2, 3, 4, 5];

      for (const pageNum of pageNumbers) {
        await page.act(`navigate to page ${pageNum}`);
        
        const pageData = await page.extract({
          instruction: "extract product data from the current page only",
          schema: ProductPageSchema,
          timeoutMs: 60000 // 60 second timeout
        });
        
        allData.push(...pageData.products);
      }
      ```

      ```python Python
      # Instead of extracting everything at once
      all_data = []
      page_numbers = [1, 2, 3, 4, 5]

      for page_num in page_numbers:
          await page.act(f"navigate to page {page_num}")
          
          page_data = await page.extract(
              "extract product data from the current page only",
              schema=ProductPageSchema,
              timeout_ms=60000  # 60 second timeout
          )
          
          all_data.extend(page_data.products)
      ```
    </CodeGroup>
  </Accordion>
</AccordionGroup>

<div id="next-steps">
  ## 下一步
</div>

<CardGroup cols={2}>
  <Card title="Act" icon="play" href="/zh/basics/act">
    基于 observe 的结果高效执行操作
  </Card>

  <Card title="Observe" icon="magnifying-glass" href="/zh/basics/observe">
    使用 observe() 分析页面
  </Card>
</CardGroup>