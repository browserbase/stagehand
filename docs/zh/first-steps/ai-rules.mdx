---
title: AI 规则
description: 借助 AI 更快、更高质量地编写 Stagehand 代码。
---

你很可能在用 AI 写代码——这件事有对也有不对的做法。此页汇集了一组规则、配置与可直接复制粘贴的片段，帮助你的 AI 代理/助手以尽可能高的效率编写高性能的 Stagehand 代码。 

## 快速开始

<CardGroup cols={2}>
  <Card title="添加 MCP 服务器" icon="screwdriver-wrench">
    在你的 MCP 客户端中配置 Browserbase（Stagehand）、Context7、DeepWiki 和 Stagehand 文档。
  </Card>
  <Card title="固定编辑器规则" icon="memo">
    添加 `cursorrules` 和 `claude.md`，让 AI 代理/助手始终遵循并生成 Stagehand 规范化模式。
  </Card>
</CardGroup>

## 使用 MCP 服务器

MCP（Model Context Protocol，模型上下文协议）服务器充当连接 AI 系统与外部数据源和工具的中介。这些服务器使你的编码助手能够访问实时信息、执行任务并检索结构化数据，从而提升代码生成的准确性。

以下这些**MCP 服务器**提供对 Stagehand 文档与相关资源的专项访问：

<Accordion title="Context7 by Upstash" icon="database">
在文档与代码库上下文中提供语义搜索。Context7 使 AI 助手能够从你的项目历史中找到相关代码模式、示例和实现细节。它会持续维护对你开发工作流的上下文理解，并可从以往工作中提炼并呈现相关解决方案。

**安装：**
```json
{
  "mcpServers": {
    "context7": {
      "command": "npx",
      "args": ["-y", "@upstash/context7-mcp"]
    }
  }
}
```
</Accordion>

<Accordion title="DeepWiki by Cognition" icon="book-open">
对 GitHub 仓库与文档进行深度索引。DeepWiki 让 AI 代理能够理解项目架构、API 参考以及整个 Stagehand 生态的最佳实践。它提供关于仓库结构、代码关系与开发模式的完整知识图谱。

**安装：**
```json
{
  "mcpServers": {
    "deepwiki": {
      "url": "https://mcp.deepwiki.com/mcp"
    }
  }
}
```
</Accordion>

<Accordion title="Stagehand Docs by Mintlify" icon="mintbit">
直接访问官方 Stagehand 文档。该 MCP 服务器为 AI 助手提供最新的 API 参考、配置选项与用法示例，助力更准确的代码生成。Mintlify 会基于官方文档自动生成此服务器，确保你的 AI 助手始终获取最新信息。

**用法：**
```json
{
  "mcpServers": {
    "stagehand-docs": {
      "url": "https://docs.stagehand.dev/mcp"
    }
  }
}
```
</Accordion>

**MCP 服务器如何提升你的开发：**
- **实时文档访问**：AI 助手可查询最新的 Stagehand 文档、示例与最佳实践
- **上下文感知的代码生成**：服务器会基于你的特定用例提供相关代码模式与配置
- **降低集成开销**：标准化协议免去针对每个文档源单独开发集成
- **提升准确性**：AI 代理获取结构化且最新的信息，而非依赖可能过时的训练数据


<Tip>
**提示：** 
明确要求你的编码代理/助手使用这些 MCP 服务器从文档中获取相关信息，从而具备更好的上下文并知道如何编写合规的 Stagehand 代码。 

例如：**“使用 stagehand-docs MCP 获取 act/observe 指南，然后按其生成代码。优先使用缓存的 observe 结果。”**
</Tip>


## 编辑器规则文件（可直接粘贴）

将这些内容放入 `.cursorrules`、`windsurfrules`、`claude.md`，或任意代理规则框架中：

<Accordion title="TypeScript">
  ```````md
  # Stagehand 项目

  这是一个使用 [Stagehand](https://github.com/browserbase/stagehand) 的项目。Stagehand 为 Playwright 提供 AI 增强，在 Page 类中加入了 `act`、`extract` 和 `observe` 方法。

  `Stagehand` 是一个提供配置与浏览器自动化能力的类，包含：
  - `stagehand.page`: 一个 StagehandPage 对象（扩展自 Playwright Page）
  - `stagehand.context`: 一个 StagehandContext 对象（扩展自 Playwright BrowserContext）
  - `stagehand.agent()`: 创建用于自主多步骤工作流的 AI 代理（Computer Use Agent 可选）
  - `stagehand.init()`: 初始化浏览器会话
  - `stagehand.close()`: 清理资源

  `Page` 在 Playwright 的 Page 类基础上扩展了 AI 驱动的方法：
  - `act()`: 使用自然语言在网页元素上执行操作
  - `extract()`: 使用模式从页面提取结构化数据
  - `observe()`: 在执行前规划动作并获取选择器

  `Agent` 提供自主的 Computer Use Agent 能力：
  - `execute()`: 使用自然语言指令执行复杂的多步骤任务

  `Context` 扩展了 Playwright 的 BrowserContext 类，用于管理浏览器会话。

  在为该项目编写代码时，请遵循以下规则。

  - 若需规划诸如“点击登录按钮”之类的指令，使用 Stagehand `observe` 获取要执行的动作。

  ```typescript
  const results = await page.observe("Click the sign in button");
  ```

  你也可以传入以下参数：

  ```typescript
  await page.observe({
    instruction: "the instruction to execute",
    returnAction: true 
  });
  ```

  - `observe` 的结果是一个由 `ObserveResult` 对象组成的数组，可直接作为 `act` 的参数使用，如下所示：
    ```typescript
    const results = await page.observe({
      instruction: "the instruction to execute",
      returnAction: true, // return the action to execute
    });

    await page.act(results[0]);
    ```
    
  - 当编写需要从页面提取数据的代码时，使用 Stagehand `extract`。默认显式传入以下参数：

  ```typescript
  const { someValue } = await page.extract({
    instruction: "the instruction to execute",
    schema: z.object({
      someValue: z.string(),
    }), // The schema to extract
  });
  ```
  ``````md

  ## 初始化

  ```typescript
  import { Stagehand, Page, BrowserContext } from "@browserbasehq/stagehand";

  const stagehand = new Stagehand({
    env: "BROWSERBASE"
  });

  await stagehand.init();

  const page = stagehand.page; // 带有 act、extract、observe 方法的 Playwright Page

  const context = stagehand.context; // Playwright BrowserContext
  ```
  ### 配置选项
  ```typescript
  const StagehandConfig = {
    env: "BROWSERBASE" | "LOCAL", // 运行环境
    apiKey: process.env.BROWSERBASE_API_KEY, // Browserbase API 密钥
    projectId: process.env.BROWSERBASE_PROJECT_ID, // Browserbase 项目 ID
    debugDom: true, // 启用 DOM 调试功能
    headless: false, // 以无头模式运行浏览器
    domSettleTimeoutMs: 30_000, // 在执行前等待 DOM 稳定的超时时间
    enableCaching: true, // 启用操作缓存
    modelName: "gpt-4o", // 使用的 AI 模型
    modelClientOptions: {
      apiKey: process.env.OPENAI_API_KEY, // OpenAI API 密钥
    },
  };
  ```
  ## Act

  你可以直接用字符串指令执行操作：

  ```typescript
  await page.act("Click the sign in button");
  ```

  使用变量进行动态表单填充：

  ```typescript
  await page.act({
    action: `Enter the following information:
      Name: %name%
      Email: %email%
      Phone: %phone%`,
    variables: {
      name: "John Doe",
      email: "john@example.com", 
      phone: "+1-555-0123"
    }
  });
  ```

  **最佳实践：**
  - 缓存 `observe` 的结果，以避免遇到意外的 DOM 变化
  - 保持操作原子且具体（例如，“Click the sign in button”，而不是 “Sign in to the website”）
  - 通过变量替换输入动态数据

  Act 的 `action` 应尽可能原子且具体，例如 “Click the sign in button” 或 “Type 'hello' into the search input”。
  避免包含多个步骤的操作，例如 “Order me pizza” 或 “Send an email to Paul asking him to call me”。

  ## 提取

  ### 简单字符串提取

  ```typescript
  const signInButtonText = await page.extract("提取“登录”按钮的文本");
  ```

  ### 基于模式的结构化提取（推荐）

  进行结构化数据提取时，应始终使用 Zod 模式：

  ```typescript
  import { z } from "zod";

  const data = await page.extract({
    instruction: "提取“登录”按钮的文本",
    schema: z.object({
      text: z.string(),
    }),
  });
  ```

  ### 数组提取

  要提取多个项目，请将数组置于单个对象中：

  ```typescript
  const data = await page.extract({
    instruction: "提取所有按钮内的文本",
    schema: z.object({
      buttons: z.array(z.string()),
    })
  });
  ```

  ### 复杂对象提取

  针对更复杂的数据结构：

  ```typescript
  const productData = await page.extract({
    instruction: "从此页面提取产品信息",
    schema: z.object({
      title: z.string(),
      price: z.number(),
      description: z.string(),
      features: z.array(z.string()),
      availability: z.boolean(),
    }),
  });
  ```

  ### 模式验证

  ```typescript
  import { validateZodSchema } from "./utils.js";
  import { z } from "zod";

  const schema = z.object({ name: z.string() });
  const isValid = validateZodSchema(schema, { name: "John" }); // true
  ```

  ## 代理系统

  Stagehand 提供用于自主网页浏览的代理系统，支持使用 Computer Use Agent（CUA）。代理可基于自然语言指令执行多步骤工作流。

  ### 创建代理

  ```typescript
  // 基础代理（默认）
  const agent = stagehand.agent();

  // OpenAI 代理
  const agent = stagehand.agent({
    provider: "openai",
    model: "computer-use-preview",
    instructions: "You are a helpful assistant that can use a web browser.",
    options: { 
      apiKey: process.env.OPENAI_API_KEY 
    }
  });

  // Anthropic 代理
  const agent = stagehand.agent({
    provider: "anthropic", 
    model: "claude-sonnet-4-20250514",
    instructions: "You are a helpful assistant that can use a web browser.",
    options: { 
      apiKey: process.env.ANTHROPIC_API_KEY 
    }
  });
  ```
  ### 代理执行
  ```typescript
  // 简单任务
  const result = await agent.execute("Extract the title from this webpage");

  // 复杂多步骤任务
  const result = await agent.execute({
    instruction: "Apply for the first engineer position with mock data",
    maxSteps: 20,
    autoScreenshot: true
  });
  ```

  ### 最佳实践
  - 指令要具体："将姓名设为 'John Doe'，填写联系表单并提交"
  - 将复杂任务拆解为更小的步骤
  - 使用 try/catch 进行错误处理
  - 结合：用代理负责导航，用传统方法进行精确的数据提取

  ```typescript
  // 推荐：具体的指令
  await agent.execute("进入产品页面并按 'Electronics' 进行筛选");

  // 避免：含糊的指令  
  await agent.execute("在这个页面上随便做点事");
  ```

  ## 项目结构最佳实践

  - 将配置存储在 `stagehand.config.ts` 中
  - 使用环境变量管理 API 密钥（参见 `.env.example`）
  - 将主要的自动化逻辑实现为接收 `{ page, context, stagehand }` 的函数
  - 使用 TypeScript，并从 `@browserbasehq/stagehand` 正确导入
  ```````
</Accordion>

<Accordion title="Python">
  ```````md
  # Stagehand Python 项目

  这是一个使用 [Stagehand Python](https://github.com/browserbase/stagehand-python) 的项目，它通过 `act`、`extract` 与 `observe` 方法提供 AI 增强的浏览器自动化能力。

  `Stagehand` 是一个类，提供以下配置与浏览器自动化能力：
  - `stagehand.page`: 一个 StagehandPage 对象（扩展自 Playwright 的 Page）
  - `stagehand.context`: 一个 StagehandContext 对象（扩展自 Playwright 的 BrowserContext）
  - `stagehand.agent()`: 创建用于自主执行多步骤工作流的 AI 代理
  - `stagehand.init()`: 初始化浏览器会话
  - `stagehand.close()`: 释放资源

  `Page` 在 Playwright 的 Page 类之上扩展了 AI 能力：
  - `act()`: 使用自然语言对网页元素执行操作
  - `extract()`: 使用模式从页面提取结构化数据
  - `observe()`: 先规划动作并获取选择器再执行

  `Agent` 提供自主的 Computer Use Agent 能力：
  - `execute()`: 根据自然语言指令执行复杂的多步骤任务

  请遵循以下规则为本项目编写代码。

  - 要规划类似“点击登录按钮”的指令，使用 Stagehand 的 `observe` 获取要执行的动作。

  ```python
  results = await page.observe("Click the sign in button")
  ```

  你也可以传入以下参数：

  ```python
  await page.observe(
      instruction="the instruction to execute",
      draw_overlay=True  # 在被观察的元素上显示可视化高亮覆盖
  )
  ```

  - `observe` 的返回值是 `ObserveResult` 对象的列表，可直接作为 `act` 的参数使用，例如：
    ```python
    results = await page.observe("Click the sign in button")
    await page.act(results[0])
    ```
  - 当需要从页面提取数据时，使用 Stagehand 的 `extract`。用 Pydantic 模型定义模式：

  ```python
  from pydantic import BaseModel

  class ExtractedData(BaseModel):
      some_value: str

  result = await page.extract(
      instruction="the instruction to execute",
      schema=ExtractedData
  )
  ```
  ``````md

  ## 初始化

  ```python
  from stagehand import Stagehand, StagehandConfig
  import asyncio
  import os
  from dotenv import load_dotenv

  load_dotenv()

  async def main():
      config = StagehandConfig(
          env="BROWSERBASE",  # 或 "LOCAL"
          api_key=os.getenv("BROWSERBASE_API_KEY"),
          project_id=os.getenv("BROWSERBASE_PROJECT_ID"),
          model_name="google/gemini-2.5-flash-preview-05-20",
          model_api_key=os.getenv("MODEL_API_KEY"),
      )
      
      # 推荐：作为异步上下文管理器使用
      async with Stagehand(config) as stagehand:
          page = stagehand.page
          # 在此编写你的自动化代码
          
      # 备选：手动初始化
      stagehand = Stagehand(config)
      await stagehand.init()
      page = stagehand.page
      # 在此编写你的自动化代码
      await stagehand.close()

  if __name__ == "__main__":
      asyncio.run(main())
  ```

  ### 配置选项

  `StagehandConfig` 中的关键配置项：

  ```python
  config = StagehandConfig(
      env="BROWSERBASE",  # 或 "LOCAL"
      api_key=os.getenv("BROWSERBASE_API_KEY"),
      project_id=os.getenv("BROWSERBASE_PROJECT_ID"),
      model_name="google/gemini-2.5-flash-preview-05-20",
      model_api_key=os.getenv("MODEL_API_KEY"),
      verbose=1,  # 0=最少日志，1=适中，2=详细
      dom_settle_timeout_ms=30000,
      self_heal=True,  # 启用 Self‑healing 功能
  )
  ```

  ## Act

  你可以直接用字符串指令调用 act（）：

  ```python
  await page.act("Click the sign in button")
  ```

  使用变量进行动态表单填写：

  ```python
  await page.act(
      "Enter the following information: Name: John Doe, Email: john@example.com"
  )
  ```

  **最佳实践：**
  - 缓存 `observe` 的结果，以避免意外的 DOM 变化
  - 保持操作原子且具体（例如，用 "Click the sign in button" 而不是 "Sign in to the website"）
  - 使用具体且具有描述性的指令

  Act 的 `action` 应尽可能原子且具体，例如 "Click the sign in button" 或 "Type 'hello' into the search input"。
  避免编写包含多步的操作，例如 "Order me pizza" 或 "Send an email to Paul asking him to call me"。

  ## 提取

  ### 简单字符串提取
  ```python
  sign_in_button_text = await page.extract("extract the sign in button text")
  ```

  ### 使用模式的结构化提取（推荐）
  进行结构化数据提取时，请始终使用 Pydantic 模型：

  ```python
  from pydantic import BaseModel, Field
  from typing import List

  class ButtonData(BaseModel):
      text: str = Field(..., description="Button text content")

  data = await page.extract(
      instruction="extract the sign in button text",
      schema=ButtonData
  )
  ```

  ### 数组提取
  对于数组，请使用 List 类型：

  ```python
  from pydantic import BaseModel, Field
  from typing import List

  class ButtonsData(BaseModel):
      buttons: List[str] = Field(..., description="List of button texts")

  data = await page.extract(
      instruction="extract the text inside all buttons",
      schema=ButtonsData
  )
  ```

  ### 复杂对象提取
  用于更复杂的数据结构：

  ```python
  from pydantic import BaseModel, Field
  from typing import List

  class Company(BaseModel):
      name: str = Field(..., description="Company name")
      description: str = Field(..., description="Brief company description")

  class Companies(BaseModel):
      companies: List[Company] = Field(..., description="List of companies")

  companies_data = await page.extract(
      "Extract names and descriptions of 5 companies",
      schema=Companies
  )
  ```

  ## 代理系统

  Stagehand 提供一套利用 Computer Use Agent（CUA）实现自主网页浏览的代理系统。

  ### 创建代理

  ```python
  # 基础代理（使用默认模型）
  agent = stagehand.agent()
  ```

  # OpenAI 代理
  agent = stagehand.agent(
      model="computer-use-preview",
      instructions="你是一名乐于助人的网页导航助理。",
      options={"apiKey": os.getenv("OPENAI_API_KEY")}
  )

  # Anthropic 代理
  agent = stagehand.agent(
      model="claude-sonnet-4-20250514",
      instructions="你是一名有帮助的网页导航助手。",
      options={"apiKey": os.getenv("ANTHROPIC_API_KEY")}
  )

  ### 代理执行

  ```python
  # 简单任务
  result = await agent.execute("玩一局 2048")
  ```

  # 带有可选项的复杂多步骤任务
  result = await agent.execute(
      instruction="使用模拟数据申请第一个工程师岗位",
      max_steps=20,
      auto_screenshot=True,
      wait_between_actions=1000  # 毫秒
  )
  ```

  **最佳实践：**
  - 明确表达指令："填写联系表单，姓名为“John Doe”，并提交"
  - 将复杂任务拆解为更小的步骤
  - 使用 try/except 块进行错误处理
  - 将用于导航的 agent 与传统方法结合，以实现精准的数据提取

  ```python
  # 优秀：具体指令
  await agent.execute("前往产品页面，并按“电子产品”筛选")
  ```

  # 避免：模糊不清的指令
  await agent.execute("在此页面上做点事情")
  ```

  ## 项目结构最佳实践

  - 将配置存储在环境变量或配置文件中
  - 始终如一地使用 async/await 模式
  - 将主要的自动化逻辑实现为异步函数
  - 使用异步上下文管理器进行资源管理
  - 使用类型注解与 Pydantic 模型进行数据验证
  - 使用 try/except 块恰当地处理异常
  ```````
</Accordion>

## 安全注意事项

- 不要在文档或规则文件中硬编码任何机密；请在 MCP 配置中使用环境变量。
- 避免可能导致意外跳转的笼统操作；请优先先使用 `observe()`。

## 资源/参考资料

- Context7 MCP（Upstash）
  - https://github.com/upstash/context7
- DeepWiki MCP
  - https://mcp.deepwiki.com/
- Stagehand 文档 MCP（Mintlify）
  - https://docs.stagehand.dev/mcp
