---
title: 可观测性
sidebarTitle: 可观测性
description: 通过会话可见性与分析追踪 Stagehand 自动化
---

Stagehand 提供强大的可观测性功能，帮助你监控、衡量性能，并分析浏览器自动化流程。重点覆盖会话监控、资源使用以及在 Browserbase 与本地环境中的运营洞察。

## Browserbase 会话监控

在 Browserbase 上运行时，你可以通过 Browserbase API 和控制台获得全面的云端监控与会话管理能力。

<div style={{ textAlign: "center" }}>
  <img src="/media/observability.gif" alt="Browserbase 会话可观测性" width="400" />
</div>

### 实时会话可视性

Browserbase 为你的自动化会话提供实时可视性：

**会话控制台功能**

- 实时浏览器屏幕录制与回放
- 带详细时序的网络请求监控
- JavaScript 控制台日志与错误跟踪
- CPU 与内存使用指标
- 会话状态与持续时间跟踪

**会话管理与 API 访问**

<CodeGroup>
  ```typescript TypeScript
  import { Stagehand } from "@browserbasehq/stagehand";
  import { Browserbase } from "@browserbasehq/sdk";

  const browserbase = new Browserbase({
    apiKey: process.env.BROWSERBASE_API_KEY,
  });

  const stagehand = new Stagehand({
    env: "BROWSERBASE"
  });

  await stagehand.init();

  const sessionInfo = await browserbase.sessions.retrieve(stagehand.sessionId);

  console.log("Session status:", sessionInfo.status);
  console.log("Session region:", sessionInfo.region);
  console.log("CPU usage:", sessionInfo.avgCpuUsage);
  console.log("Memory usage:", sessionInfo.memoryUsage);
  console.log("Proxy bytes:", sessionInfo.proxyBytes);
  ```

  ```python Python
  import os
  from stagehand import Stagehand
  from browserbase import Browserbase

  browserbase = Browserbase(
    api_key=os.getenv("BROWSERBASE_API_KEY"),
  )

  stagehand = Stagehand(
      env="BROWSERBASE",
  )

  await stagehand.init()

  session_info = browserbase.sessions.retrieve(stagehand.session_id)

  print(f"Session status: {session_info['status']}")
  print(f"Session region: {session_info['region']}")
  print(f"CPU usage: {session_info['avgCpuUsage']}")
  print(f"Memory usage: {session_info['memoryUsage']}")
  print(f"Proxy bytes: {session_info['proxyBytes']}")
  ```
</CodeGroup>

### 会话分析与洞察

<CardGroup>
  <Card title="Real-Time Monitoring" icon="chart-line">
    监控实时会话状态、资源使用与地理分布。基于实时洞察扩缩并管理并发会话。
  </Card>

  <Card title="Session Recordings" icon="video">
    查看完整会话录制，逐帧回放。可视化分析网络请求并调试浏览器交互。
  </Card>

  <Card title="API Management" icon="code">
    以编程方式访问会话数据，自动化生命周期管理，并通过我们的 API 集成到监控系统。
  </Card>

  <Card title="Usage Monitoring" icon="chart-bar">
    跟踪资源消耗、会话时长与 API 使用情况。获取自动化各环节的成本与利用率明细。
  </Card>
</CardGroup>

### 会话监控与筛选

按状态与元数据查询并监控会话：

<CodeGroup>
  ```typescript TypeScript
  import { Browserbase } from "@browserbasehq/sdk";

  const browserbase = new Browserbase({
    apiKey: process.env.BROWSERBASE_API_KEY,
  });

  // List sessions with filtering
  async function getFilteredSessions() {
    const sessions = await browserbase.sessions.list({
      status: 'RUNNING'
    });
    
    return sessions.map(session => ({
      id: session.id,
      status: session.status, // RUNNING, COMPLETED, ERROR, TIMED_OUT
      startedAt: session.startedAt,
      endedAt: session.endedAt,
      region: session.region,
      avgCpuUsage: session.avgCpuUsage,
      memoryUsage: session.memoryUsage,
      proxyBytes: session.proxyBytes,
      userMetadata: session.userMetadata
    }));
  }

  // Query sessions by metadata
  async function querySessionsByMetadata(query: string) {
    const sessions = await browserbase.sessions.list({
      q: query
    });
    
    return sessions;
  }
  ```

  ```python Python
  import os
  from browserbase import Browserbase

  browserbase = Browserbase(
      api_key=os.getenv("BROWSERBASE_API_KEY"),
  )

  def get_filtered_sessions():
      sessions = browserbase.sessions.list(status="RUNNING")
      
      return [{
          'id': session['id'],
          'status': session['status'],  # RUNNING, COMPLETED, ERROR, TIMED_OUT
          'started_at': session['startedAt'],
          'ended_at': session['endedAt'],
          'region': session['region'],
          'avg_cpu_usage': session['avgCpuUsage'],
          'memory_usage': session['MemoryUsage'] if 'MemoryUsage' in session else session['memoryUsage'],
          'proxy_bytes': session['proxyBytes'],
          'user_metadata': session['userMetadata']
      } for session in sessions]

  def query_sessions_by_metadata(query):
      sessions = browserbase.sessions.list(q=query)
      
      return sessions
  ```
</CodeGroup>

## 本地环境监控

在本地开发中，Stagehand 可直接在你的机器上提供性能监控与资源跟踪能力。

### 性能监测

<CodeGroup>
  ```typescript TypeScript
  import { Stagehand } from "@browserbasehq/stagehand";

  const stagehand = new Stagehand({
    env: "LOCAL",
    verbose: 1, // 在不输出调试噪声的情况下监控性能
  });

  // 跟踪本地自动化指标
  const startTime = Date.now();
  const initialMetrics = stagehand.metrics;

  // ... 执行自动化任务

  const finalMetrics = stagehand.metrics;
  const executionTime = Date.now() - startTime;

  console.log('Local Performance Summary:', {
    executionTime: `${executionTime}ms`,
    totalTokens: finalMetrics.totalPromptTokens + finalMetrics.totalCompletionTokens,
    averageResponseTime: finalMetrics.totalInferenceTimeMs / 3, // 假设执行了 3 次操作
    tokensPerSecond: (finalMetrics.totalPromptTokens + finalMetrics.totalCompletionTokens) / (executionTime / 1000)
  });
  ```

  ```python Python
  from stagehand import Stagehand
  import time

  stagehand = Stagehand(
      env="LOCAL",
      verbose=1,  # 在不输出调试噪声的情况下监控性能
  )

  # 跟踪本地自动化指标
  start_time = time.time()
  initial_metrics = stagehand.metrics

  # ... 执行自动化任务

  final_metrics = stagehand.metrics
  execution_time = (time.time() - start_time) * 1000  # 转换为毫秒

  print('Local Performance Summary:', {
      'execution_time': f"{execution_time:.0f}ms",
      'total_tokens': final_metrics['total_prompt_tokens'] + final_metrics['total_completion_tokens'],
      'average_response_time': final_metrics['total_inference_time_ms'] / 3,  # 假设执行了 3 次操作
      'tokens_per_second': (final_metrics['total_prompt_tokens'] + final_metrics['total_completion_tokens']) / (execution_time / 1000)
  })
  ```
</CodeGroup>

## 资源使用监控

在本地运行时，监控系统资源占用与浏览器性能：

<CodeGroup>
  ```typescript TypeScript
  import { Stagehand } from "@browserbasehq/stagehand";
  import * as os from 'os';
  import { performance } from 'perf_hooks';

  class LocalResourceMonitor {
    private cpuUsage: number[] = [];
    private memoryUsage: number[] = [];
    
    startMonitoring() {
      const interval = setInterval(() => {
        // Track system resources
        const memUsage = process.memoryUsage();
        this.memoryUsage.push(memUsage.heapUsed / 1024 / 1024); // MB
        
        // Track CPU (simplified)
        const loadAvg = os.loadavg()[0];
        this.cpuUsage.push(loadAvg);
      }, 1000);
      
      return interval;
    }
    
    getResourceSummary() {
      return {
        avgMemoryUsage: this.memoryUsage.reduce((a, b) => a + b, 0) / this.memoryUsage.length,
        peakMemoryUsage: Math.max(...this.memoryUsage),
        avgCpuLoad: this.cpuUsage.reduce((a, b) => a + b, 0) / this.cpuUsage.length,
        totalDataPoints: this.cpuUsage.length
      };
    }
  }

  const monitor = new LocalResourceMonitor();
  const interval = monitor.startMonitoring();

  const stagehand = new Stagehand({ env: "LOCAL" });

  // ... run automation

  clearInterval(interval);
  console.log('Resource Usage:', monitor.getResourceSummary());
  ```

  ```python Python
  import psutil
  import time
  from typing import List
  from stagehand import Stagehand

  class LocalResourceMonitor:
      def __init__(self):
          self.cpu_usage: List[float] = []
          self.memory_usage: List[float] = []
          self.monitoring = False
      
      def start_monitoring(self):
          self.monitoring = True
          import threading
          
          def monitor_resources():
              while self.monitoring:
                  # Track CPU and memory usage
                  cpu_percent = psutil.cpu_percent(interval=1)
                  memory_info = psutil.virtual_memory()
                  
                  self.cpu_usage.append(cpu_percent)
                  self.memory_usage.append(memory_info.percent)
                  
                  time.sleep(1)
          
          thread = threading.Thread(target=monitor_resources)
          thread.daemon = True
          thread.start()
          return thread
      
      def stop_monitoring(self):
          self.monitoring = False
      
      def get_resource_summary(self):
          if not self.cpu_usage or not self.memory_usage:
              return {'error': 'No monitoring data collected'}
          
          return {
              'avg_cpu_usage': sum(self.cpu_usage) / len(self.cpu_usage),
              'peak_cpu_usage': max(self.cpu_usage),
              'avg_memory_usage': sum(self.memory_usage) / len(self.memory_usage),
              'peak_memory_usage': max(self.memory_usage),
              'total_data_points': len(self.cpu_usage)
          }

  monitor = LocalResourceMonitor()
  monitor.start_monitoring()

  stagehand = Stagehand(env="LOCAL")

  # ... run automation

  monitor.stop_monitoring()
  print('Resource Usage:', monitor.get_resource_summary())
  ```
</CodeGroup>

<Card title="LLM Usage" icon="chart-line" href="/zh/configuration/evals">
  监控 Token 使用量、成本与速度；为关键故障设置自动告警；在不同环境间进行成本跟踪；利用会话分析优化自动化工作流。
</Card>

## 实时指标与监控

### 基本用量跟踪

使用 `stagehand.metrics` 实时监控你的自动化资源使用情况：

<CodeGroup>
  ```typescript TypeScript
  // 获取当前指标
  console.log(stagehand.metrics);

  // 在自动化过程中进行监控
  const startTime = Date.now();
  const initialMetrics = stagehand.metrics;

  // ... 执行自动化任务

  const finalMetrics = stagehand.metrics;
  const executionTime = Date.now() - startTime;

  console.log('Automation Summary:', {
    totalTokens: finalMetrics.totalPromptTokens + finalMetrics.totalCompletionTokens,
    totalCost: calculateCost(finalMetrics),
    executionTime,
    efficiency: (finalMetrics.totalPromptTokens + finalMetrics.totalCompletionTokens) / executionTime
  });
  ```

  ```python Python
  # 获取当前指标
  print(stagehand.metrics)

  # 在自动化过程中进行监控
  import time
  start_time = time.time()
  initial_metrics = stagehand.metrics

  # ... 执行自动化任务

  final_metrics = stagehand.metrics
  execution_time = (time.time() - start_time) * 1000  # 转为毫秒

  print('Automation Summary:', {
      'total_tokens': final_metrics['total_prompt_tokens'] + final_metrics['total_completion_tokens'],
      'total_cost': calculate_cost(final_metrics),
      'execution_time': execution_time,
      'efficiency': (final_metrics['total_prompt_tokens'] + final_metrics['total_completion_tokens']) / execution_time
  })
  ```
</CodeGroup>

### 解读指标数据

该指标对象会按 Stagehand 操作提供详细拆分：

<CodeGroup>
  ```typescript TypeScript
  {
    actPromptTokens: 4011,
    actCompletionTokens: 51,
    actInferenceTimeMs: 1688,

    extractPromptTokens: 4200,
    extractCompletionTokens: 243,
    extractInferenceTimeMs: 4297,

    observePromptTokens: 347,
    observeCompletionTokens: 43,
    observeInferenceTimeMs: 903,

    totalPromptTokens: 8558,
    totalCompletionTokens: 337,
    totalInferenceTimeMs: 6888
  }
  ```

  ```python Python
  {
    "act_prompt_tokens": 4011,
    "act_completion_tokens": 51,
    "act_inference_time_ms": 1688,

    "extract_prompt_tokens": 4200,
    "extract_completion_tokens": 243,
    "extract_inference_time_ms": 4297,

    "observe_prompt_tokens": 347,
    "observe_completion_tokens": 43,
    "observe_inference_time_ms": 903,

    "total_prompt_tokens": 8558,
    "total_completion_tokens": 337,
    "total_inference_time_ms": 6888
  }
  ```
</CodeGroup>

### 将推理记录到文件

你也可以将 `logInferenceToFile` 设为 `true`，把推理日志写入文件。此操作会在项目根目录创建一个名为 `inference_summary` 的目录。

<CodeGroup>
  ```typescript TypeScript
  const stagehand = new Stagehand({
    logInferenceToFile: true,    
  });
  ```

  ```python Python
  stagehand = Stagehand(
      log_inference_to_file=True,             
  )
  ```
</CodeGroup>

`inference_summary` 目录提供更细粒度的分析数据：

```
inference_summary/
├── act_summary/
│   ├── {timestamp}.json
│   ├── {timestamp}.json
│   └── ...
│   └── act_summary.json
├── extract_summary/
│   ├── {timestamp}.json
│   ├── {timestamp}.json
│   └── ...
│   └── extract_summary.json
├── observe_summary/
│   ├── {timestamp}.json
│   ├── {timestamp}.json
│   └── ...
│   └── observe_summary.json
```

### 日志文件结构

每个操作都会生成用于分析的详细日志：

```typescript
{
  "act_summary": [
    {
      "act_inference_type": "act",
      "timestamp": "20250329_080446068",
      "LLM_input_file": "20250329_080446068_act_call.txt",
      "LLM_output_file": "20250329_080447019_act_response.txt",
      "prompt_tokens": 3451,
      "completion_tokens": 45,
      "inference_time_ms": 951
    },
    ...
  ],
}
```

## 最佳实践

<AccordionGroup>
  <Accordion title="生产监控">
    - 跟踪会话成功率与失败模式
    - 监控资源使用与扩容需求
    - 为关键故障配置自动告警
    - 跨环境实施成本追踪
    - 利用会话分析优化自动化流程
  </Accordion>

  <Accordion title="性能优化">
    - 比较 Browserbase 与本地执行时间
    - 跨模型监控 token 消耗与推理成本
    - 跟踪不同地域的性能差异
    - 识别自动化流程中的瓶颈
    - 面向性价比与速度进行优化
  </Accordion>

  <Accordion title="运营洞察">
    - 跟踪各地区的会话分布
    - 监控并发会话上限与弹性扩容
    - 分析失败模式与常见错误场景
    - 通过会话录制进行根因分析
    - 使用自定义元数据对流程进行分类
  </Accordion>

  <Accordion title="集成与告警">
    - 将会话 API 接入监控看板
    - 为会话失败配置自动通知
    - 跟踪 SLA 合规性与性能基准
    - 监控资源成本与使用模式
    - 用分析数据进行容量规划与优化
  </Accordion>
</AccordionGroup>

有关详细日志与调试功能，请参见 [Logging](/zh/configuration/logging)。