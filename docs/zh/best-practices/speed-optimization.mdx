---
title: 速度优化
sidebarTitle: 速度优化
description: 优化 Stagehand 性能，实现更快的自动化与更低的延迟
---

Stagehand 的性能受多种因素影响：DOM 处理速度、LLM 推理时间、浏览器操作以及网络延迟。本指南提供行之有效的策略，帮助最大化自动化速度。

<div id="quick-performance-wins">
  ## 快速性能优化
</div>

<div id="1-plan-ahead-with-observe">
  ### 1. 使用 Observe 提前规划
</div>

通过一次 `observe()` 调用规划多个动作，然后高效执行：

<CodeGroup>
  ```typescript TypeScript
  // 避免用多次 LLM 调用顺序执行
  await page.act("Fill name field");        // LLM call #1
  await page.act("Fill email field");       // LLM call #2
  await page.act("Select country dropdown"); // LLM call #3

  // 使用一次 observe 规划所有表单字段——仅一次 LLM 调用
  const formFields = await page.observe("Find all form fields to fill");

  // 在不进行 LLM 推理的情况下执行所有操作
  for (const field of formFields) {
    await page.act(field); // 无 LLM 调用！
  }

  ```

  ```python Python
  import asyncio

  # 避免用多次 LLM 调用顺序执行
  await page.act("Fill name field")        # LLM call #1
  await page.act("Fill email field")       # LLM call #2  
  await page.act("Select country dropdown") # LLM call #3

  # 使用一次 observe 规划所有表单字段——仅一次 LLM 调用
  form_fields = await page.observe("Find all form fields to fill")

  # 在不进行 LLM 推理的情况下执行所有操作
  for field in form_fields:
      await page.act(field) # 无 LLM 调用！

  ```
</CodeGroup>

<Note>
  **性能提示**：基于 `observe` 结果执行可完全避免 LLM 推理。该方式相比直接调用 `act()` 快 2-3 倍，是多步骤工作流的推荐范式。
</Note>

<Card title="Caching Guide" icon="database" href="/zh/best-practices/caching">
  学习高级缓存模式与缓存失效策略
</Card>

<div id="2-optimize-dom-processing">
  ### 2. 优化 DOM 处理
</div>

在 Stagehand 处理页面前先降低 DOM 复杂度：

<CodeGroup>
  ```typescript TypeScript
  // 移除会拖慢处理的重型元素
  await page.evaluate(() => {
    // 移除视频等元素
    document.querySelectorAll('video, iframe').forEach(el => el.remove());
    
    // 禁用复杂动画
    document.querySelectorAll('[style*="animation"]').forEach(el => {
      (el as HTMLElement).style.animation = 'none';
    });
  });

  // 然后执行 Stagehand 操作
  await page.act("Click the submit button");
  ```

  ```python Python
  # 移除会拖慢处理的重型元素
  await page.evaluate("""
  () => {
    // 移除视频等元素
    document.querySelectorAll('video, iframe').forEach(el => el.remove());
    
    // 禁用复杂动画
    document.querySelectorAll('[style*="animation"]').forEach(el => {
      el.style.animation = 'none';
    });
  }
  """)

  # 然后执行 Stagehand 操作
  await page.act("Click the submit button")
  ```
</CodeGroup>

<div id="3-set-appropriate-timeouts">
  ### 3. 设置合适的超时时间
</div>

简单操作用更短的超时，复杂页面加载用更长的超时：

<CodeGroup>
  ```typescript TypeScript
  // 简单操作——缩短动作超时
  await page.act({ 
    instruction: "Click the login button",
    actTimeout: 5000  // 默认 30000ms，简单点击可缩短
  });

  // 复杂页面加载——优化导航
  await page.goto("https://heavy-spa.com", {
    waitUntil: "domcontentloaded", // 不必等待全部资源
    timeout: 15000 // 比默认 30s 更短
  });
  ```

  ```python Python
  # 简单操作——缩短动作超时
  await page.act("Click button", act_timeout=5000)


  # 复杂页面加载——优化导航
  await page.goto("https://heavy-spa.com", 
      wait_until="domcontentloaded",
      timeout=15000
  )
  ```
</CodeGroup>

<div id="advanced-performance-strategies">
  ## 高级性能策略
</div>

<div id="smart-model-selection">
  ### 智能模型选择
</div>

对简单任务使用更快的模型，只有在必要时才使用高阶模型：

<CodeGroup>
  ```typescript TypeScript
  class SpeedOptimizedStagehand {
    private fastModel: Stagehand;
    private premiumModel: Stagehand;

    async smartAct(page: Page, prompt: string, complexity: 'simple' | 'complex') {
      const model = complexity === 'simple' ? this.fastModel : this.premiumModel;
      return await model.page.act(prompt);
    }
  }

  // Use fast model for simple clicks/forms
  await stagehand.smartAct(page, "Click submit", 'simple');

  // Use premium model for complex reasoning
  await stagehand.smartAct(page, "Find the cheapest flight option", 'complex');
  ```

  ```python Python
  class SpeedOptimizedStagehand:
      def __init__(self):
          self.fast_model = Stagehand(model_name="fast-model")
          self.premium_model = Stagehand(model_name="premium-model")
      
      async def smart_act(self, page, prompt: str, complexity: str):
          model = self.fast_model if complexity == 'simple' else self.premium_model
          return await model.page.act(prompt)

  # Use fast model for simple clicks/forms
  await stagehand.smart_act(page, "Click submit", 'simple')

  # Use premium model for complex reasoning  
  await stagehand.smart_act(page, "Find the cheapest flight option", 'complex')
  ```
</CodeGroup>

<Card title="模型配置" icon="brain" href="/zh/configuration/models">
  比较模型性能与成本
</Card>

<div id="page-load-optimization">
  ### 页面加载优化
</div>

在页面加载时跳过不必要的资源：

<CodeGroup>
  ```typescript TypeScript
  // Block heavy resources globally
  await context.route('**/*', (route) => {
    const resourceType = route.request().resourceType();
    if (['image', 'font', 'media'].includes(resourceType)) {
      route.abort();
    } else {
      route.continue();
    }
  });

  // Use faster navigation
  await page.goto(url, { 
    waitUntil: 'domcontentloaded',  // Don't wait for images/fonts
    timeout: 10000 
  });
  ```

  ```python Python
  # Block heavy resources globally
  async def handle_route(route):
      resource_type = route.request.resource_type
      if resource_type in ['image', 'font', 'media']:
          await route.abort()
      else:
          await route.continue_()

  await context.route('**/*', handle_route)

  # Use faster navigation
  await page.goto(url, 
      wait_until='domcontentloaded',  # Don't wait for images/fonts
      timeout=10000
  )
  ```
</CodeGroup>

<Card title="成本优化" icon="dollar-sign" href="/zh/best-practices/cost-optimization">
  在速度与成本之间取得平衡
</Card>

<div id="performance-monitoring-and-benchmarking">
  ## 性能监控与基准测试
</div>

跟踪性能指标并评估优化成效：

<div id="performance-tracking">
  ### 性能追踪
</div>

<CodeGroup>
  ```typescript TypeScript
  class PerformanceTracker {
    private speedMetrics: Map<string, number[]> = new Map();

    async timedAct(page: Page, prompt: string): Promise<ActResult> {
      const start = Date.now();
      const result = await page.act(prompt);
      const duration = Date.now() - start;
      
      if (!this.speedMetrics.has(prompt)) {
        this.speedMetrics.set(prompt, []);
      }
      this.speedMetrics.get(prompt)!.push(duration);
      
      console.log(`Action "${prompt}" took ${duration}ms`);
      return result;
    }

    getAverageTime(prompt: string): number {
      const times = this.speedMetrics.get(prompt) || [];
      return times.reduce((a, b) => a + b, 0) / times.length;
    }
  }
  ```

  ```python Python
  import time
  from collections import defaultdict

  class PerformanceTracker:
      def __init__(self):
          self.speed_metrics = defaultdict(list)
      
      async def timed_act(self, page, prompt: str):
          start = time.time()
          result = await page.act(prompt)
          duration = (time.time() - start) * 1000  # 转换为毫秒
          
          self.speed_metrics[prompt].append(duration)
          print(f'Action "{prompt}" took {duration:.0f}ms')
          return result
      
      def get_average_time(self, prompt: str) -> float:
          times = self.speed_metrics[prompt]
          return sum(times) / len(times) if times else 0
  ```
</CodeGroup>

示例输出：

```
Action "Fill form" took 1000ms
Action "Click submit" took 2000ms
Action "Confirm submission" took 5000ms
```

<div id="before-vs-after-benchmarking">
  ### 优化前后基准对比
</div>

<CodeGroup>
  ```typescript TypeScript
  // 优化前
  console.time("workflow");
  await page.act("Fill form");
  await page.act("Click submit");
  await page.act("Confirm submission");
  console.timeEnd("workflow"); // 8000ms

  // 使用 observe 规划后的优化
  console.time("workflow-optimized");
  const workflowActions = await page.observe("Find form, submit, and confirm elements");

  // 依次执行动作以避免冲突
  for (const action of workflowActions) {
    await page.act(action);
  }
  console.timeEnd("workflow-optimized"); // 500ms
  ```

  ```python Python
  import time

  # 优化前
  start = time.time()
  await page.act("Fill form")
  await page.act("Click submit") 
  await page.act("Confirm submission")
  print(f"Workflow took {(time.time() - start) * 1000:.0f}ms")  # 8000ms

  # 使用 observe 规划后的优化
  start = time.time()
  workflow_actions = await page.observe("Find form, submit, and confirm elements")

  # 依次执行动作以避免冲突
  for action in workflow_actions:
      await page.act(action)
  print(f"Optimized workflow took {(time.time() - start) * 1000:.0f}ms")  # 500ms
  ```
</CodeGroup>

示例输出：

```
Workflow took 8000ms
Optimized workflow took 500ms
```

<CardGroup cols={1}>
  <Card title="可观测性与指标" icon="chart-line" href="/zh/configuration/observability">
    配置完善的性能监控
  </Card>
</CardGroup>

<div id="related-resources">
  ## 相关资源
</div>

<CardGroup cols={2}>
  <Card title="缓存策略" icon="database" href="/zh/best-practices/caching">
    面向极致性能的高级缓存策略
  </Card>

  <Card title="成本优化" icon="dollar-sign" href="/zh/best-practices/cost-optimization">
    在速度提升与成本之间取得最佳平衡
  </Card>

  <Card title="浏览器配置" icon="window-maximize" href="/zh/configuration/browser">
    优化 Browserbase 设置以提升速度
  </Card>

  <Card title="模型选择" icon="brain" href="/zh/configuration/models">
    在速度与准确性之间选择合适的模型
  </Card>
</CardGroup>