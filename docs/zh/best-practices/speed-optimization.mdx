---
title: 速度优化
sidebarTitle: 速度优化
description: 优化 Stagehand 的性能，加快自动化并降低延迟
---

Stagehand 的性能取决于多种因素：DOM 处理速度、LLM 推理耗时、浏览器操作以及网络延迟。本指南提供行之有效的策略，助你最大化自动化速度。

## 快速性能优化

### 1. 预先规划：使用 observe()

用一次 `observe()` 来规划多个操作，然后高效执行：

<CodeGroup>
  ```typescript TypeScript
  // Instead of sequential operations with multiple LLM calls
  await page.act("Fill name field");        // LLM call #1
  await page.act("Fill email field");       // LLM call #2
  await page.act("Select country dropdown"); // LLM call #3

  // Use single observe to plan all form fields - one LLM call
  const formFields = await page.observe("Find all form fields to fill");

  // Execute all actions without LLM inference
  for (const field of formFields) {
    await page.act(field); // No LLM calls!
  }

  ```

  ```python Python
  import asyncio

  # Instead of sequential operations with multiple LLM calls
  await page.act("Fill name field")        # LLM call #1
  await page.act("Fill email field")       # LLM call #2  
  await page.act("Select country dropdown") # LLM call #3

  # Use single observe to plan all form fields - one LLM call
  form_fields = await page.observe("Find all form fields to fill")

  # Execute all actions without LLM inference
  for field in form_fields:
      await page.act(field) # No LLM calls!

  ```
</CodeGroup>

<Note>
  **性能提示**：对 `observe()` 的结果直接执行可完全避免 LLM 推理。相比直接调用 `act()`，该方式通常快 2–3 倍，是多步骤流程的推荐模式。
</Note>

<Card title="缓存指南" icon="database" href="/zh/best-practices/caching">
  学习高级缓存模式与缓存失效策略
</Card>

### 2. 优化 DOM 处理

在 Stagehand 处理页面前先降低 DOM 复杂度：

<CodeGroup>
  ```typescript TypeScript
  // Remove heavy elements that slow down processing
  await page.evaluate(() => {
    // Remove video elements
    document.querySelectorAll('video, iframe').forEach(el => el.remove());
    
    // Hide complex animations
    document.querySelectorAll('[style*="animation"]').forEach(el => {
      (el as HTMLElement).style.animation = 'none';
    });
  });

  // Then perform Stagehand operations
  await page.act("Click the submit button");
  ```

  ```python Python
  # Remove heavy elements that slow down processing
  await page.evaluate("""
  () => {
    // Remove video elements
    document.querySelectorAll('video, iframe').forEach(el => el.remove());
    
    // Hide complex animations
    document.querySelectorAll('[style*="animation"]').forEach(el => {
      el.style.animation = 'none';
    });
  }
  """)

  # Then perform Stagehand operations
  await page.act("Click the submit button")
  ```
</CodeGroup>

### 3. 设置合理的超时时间

简单操作用更短超时，复杂页面加载用更长超时：

<CodeGroup>
  ```typescript TypeScript
  // Simple actions - reduce action timeout
  await page.act({ 
    instruction: "Click the login button",
    actTimeout: 5000  // Default is 30000ms, reduce for simple clicks
  });

  // Complex page loads - optimize navigation
  await page.goto("https://heavy-spa.com", {
    waitUntil: "domcontentloaded", // Don't wait for all resources
    timeout: 15000 // Shorter than default 30s
  });
  ```

  ```python Python
  # Simple actions - reduce action timeout
  await page.act("Click button", act_timeout=5000)


  # Complex page loads - optimize navigation
  await page.goto("https://heavy-spa.com", 
      wait_until="domcontentloaded",
      timeout=15000
  )
  ```
</CodeGroup>

## 高级性能策略

### 智能模型选择

简单任务用更快的模型，只有在确有必要时才用高端模型：

<CodeGroup>
  ```typescript TypeScript
  class SpeedOptimizedStagehand {
    private fastModel: Stagehand;
    private premiumModel: Stagehand;

    async smartAct(page: Page, prompt: string, complexity: 'simple' | 'complex') {
      const model = complexity === 'simple' ? this.fastModel : this.premiumModel;
      return await model.page.act(prompt);
    }
  }

  // 简单点击/表单用快速模型
  await stagehand.smartAct(page, "Click submit", 'simple');

  // 复杂推理用高端模型
  await stagehand.smartAct(page, "Find the cheapest flight option", 'complex');
  ```

  ```python Python
  class SpeedOptimizedStagehand:
      def __init__(self):
          self.fast_model = Stagehand(model_name="fast-model")
          self.premium_model = Stagehand(model_name="premium-model")
      
      async def smart_act(self, page, prompt: str, complexity: str):
          model = self.fast_model if complexity == 'simple' else self.premium_model
          return await model.page.act(prompt)

  # 简单点击/表单用快速模型
  await stagehand.smart_act(page, "Click submit", 'simple')

  # 复杂推理用高端模型  
  await stagehand.smart_act(page, "Find the cheapest flight option", 'complex')
  ```
</CodeGroup>

<Card title="模型配置" icon="brain" href="/zh/configuration/models">
  比较模型性能与成本
</Card>

### 页面加载优化

在页面加载时跳过不必要的资源：

<CodeGroup>
  ```typescript TypeScript
  // 全局阻止重量级资源
  await context.route('**/*', (route) => {
    const resourceType = route.request().resourceType();
    if (['image', 'font', 'media'].includes(resourceType)) {
      route.abort();
    } else {
      route.continue();
    }
  });

  // 使用更快的导航
  await page.goto(url, { 
    waitUntil: 'domcontentloaded',  // 不等待图片/字体
    timeout: 10000 
  });
  ```

  ```python Python
  # 全局阻止重量级资源
  async def handle_route(route):
      resource_type = route.request.resource_type
      if resource_type in ['image', 'font', 'media']:
          await route.abort()
      else:
          await route.continue_()

  await context.route('**/*', handle_route)

  # 使用更快的导航
  await page.goto(
      url, 
      wait_until='domcontentloaded',  # 不等待图片/字体
      timeout=10000
  )
  ```
</CodeGroup>

<Card title="成本优化" icon="dollar-sign" href="/zh/best-practices/cost-optimization">
  在速度与成本之间取得平衡
</Card>

## 性能监控与基准评测

跟踪性能指标并衡量优化影响：

### 性能追踪

<CodeGroup>
  ```typescript TypeScript
  class PerformanceTracker {
    private speedMetrics: Map<string, number[]> = new Map();

    async timedAct(page: Page, prompt: string): Promise<ActResult> {
      const start = Date.now();
      const result = await page.act(prompt);
      const duration = Date.now() - start;
      
      if (!this.speedMetrics.has(prompt)) {
        this.speedMetrics.set(prompt, []);
      }
      this.speedMetrics.get(prompt)!.push(duration);
      
      console.log(`Action "${prompt}" took ${duration}ms`);
      return result;
    }

    getAverageTime(prompt: string): number {
      const times = this.speedMetrics.get(prompt) || [];
      return times.reduce((a, b) => a + b, 0) / times.length;
    }
  }
  ```

  ```python Python
  import time
  from collections import defaultdict

  class PerformanceTracker:
      def __init__(self):
          self.speed_metrics = defaultdict(list)
      
      async def timed_act(self, page, prompt: str):
          start = time.time()
          result = await page.act(prompt)
          duration = (time.time() - start) * 1000  # 转为毫秒
          
          self.speed_metrics[prompt].append(duration)
          print(f'Action "{prompt}" took {duration:.0f}ms')
          return result
      
      def get_average_time(self, prompt: str) -> float:
          times = self.speed_metrics[prompt]
          return sum(times) / len(times) if times else 0
  ```
</CodeGroup>

示例输出：

```
Action "Fill form" took 1000ms
Action "Click submit" took 2000ms
Action "Confirm submission" took 5000ms
```

### 优化前后对比基准

<CodeGroup>
  ```typescript TypeScript
  // 优化前
  console.time("workflow");
  await page.act("Fill form");
  await page.act("Click submit");
  await page.act("Confirm submission");
  console.timeEnd("workflow"); // 8000ms

  // 使用 observe 规划后的优化
  console.time("workflow-optimized");
  const workflowActions = await page.observe("Find form, submit, and confirm elements");

  // 顺序执行以避免冲突
  for (const action of workflowActions) {
    await page.act(action);
  }
  console.timeEnd("workflow-optimized"); // 500ms
  ```

  ```python Python
  import time

  # 优化前
  start = time.time()
  await page.act("Fill form")
  await page.act("Click submit")
  await page.act("Confirm submission")
  print(f"Workflow took {(time.time() - start) * 1000:.0f}ms")  # 8000ms

  # 使用 observe 规划后的优化
  start = time.time()
  workflow_actions = await page.observe("Find form, submit, and confirm elements")

  # 顺序执行以避免冲突
  for action in workflow_actions:
      await page.act(action)
  print(f"Optimized workflow took {(time.time() - start) * 1000:.0f}ms")  # 500ms
  ```
</CodeGroup>

示例输出：

```
Workflow took 8000ms
Optimized workflow took 500ms
```

<CardGroup cols={1}>
  <Card title="可观测性与指标" icon="chart-line" href="/zh/configuration/observability">
    配置完善的性能监控
  </Card>
</CardGroup>

## 相关资源

<CardGroup cols={2}>
  <Card title="Caching Strategies" icon="database" href="/zh/best-practices/caching">
    面向极致性能的高级缓存策略
  </Card>

  <Card title="Cost Optimization" icon="dollar-sign" href="/zh/best-practices/cost-optimization">
    在速度提升与成本之间取得平衡
  </Card>

  <Card title="Browser Configuration" icon="window-maximize" href="/zh/configuration/browser">
    为速度优化 Browserbase 配置
  </Card>

  <Card title="Model Selection" icon="brain" href="/zh/configuration/models">
    在速度与准确性之间选择合适的模型
  </Card>
</CardGroup>