---
title: "构建网页浏览代理"
description: "使用 Stagehand 构建可自主控制浏览器的 AI 代理"
---

import { Excalidraw } from '/snippets/excalidraw.mdx';

Stagehand 为 AI 代理提供强大的工具，帮助其完全自主地控制浏览器。请观看下方示例：一个 Stagehand 代理如何自主打开指定 URL、在页面上执行操作，并提取结构化数据来回答问题。
使用 Stagehand 构建代理的方法有不少。我们来看看其中的几种。

![Agent](/media/stagehand-agent.gif)

## Stagehand MCP

上面的示例展示了一个使用 Stagehand 控制浏览器的 Claude 代理。撰写本文时，[多模态工具调用](https://sdk.vercel.ai/docs/ai-sdk-core/tools-and-tool-calling#multi-modal-tool-results) 仅在 Claude 3.5/3.7 Sonnet 中受支持。
这意味着 Claude 足够智能，知道何时请求浏览器截图，并可基于该截图决定下一步要执行的操作。

<CardGroup>
  <Card title="Browserbase MCP" href="https://github.com/browserbase/mcp-server-browserbase/" icon="hand-horns">
    使用由 Stagehand 驱动的 Browserbase MCP 控制浏览器
  </Card>
</CardGroup>

更有意思的是，代理能够将对浏览器状态的推理与具体操作分离！\
Claude 负责对浏览器状态进行推理，而 Stagehand 则可使用 GPT-4o-mini 或 Computer Use 模型在页面上执行操作。
Stagehand 甚至足够智能，能在合适场景（例如检测到 iframe 时）判断该使用 GPT-4o-mini 还是 Computer Use 模型。

<Excalidraw className="w-full aspect-video" url="https://link.excalidraw.com/readonly/GWQWmWUBqMBEAamlWsIM?darkMode=true" />

我们发现，让 Claude 作为“Trajectory”代理在合适时机调用 Stagehand 工具，成效显著！\
尽管 MCP 仍处于早期阶段，但我们对其发展充满期待。

## Stagehand + Computer Use 模型

只需一行代码，Stagehand 即可调用 OpenAI 与 Anthropic 提供的强大 Computer Use API。

<CodeGroup>
  ```typescript TypeScript
  await page.goto("https://github.com/browserbase/stagehand");

  // 仅用一行代码创建一个 Computer Use 代理！
  const agent = stagehand.agent({
  	provider: "openai",
  	model: "computer-use-preview"
  });

  // 使用该代理执行任务
  const result = await agent.execute("Extract the top contributor's username");
  console.log(result);
  ```

  ```python Python
  await page.goto("https://github.com/browserbase/stagehand-python")

  # 仅用一行代码创建一个 Computer Use 代理！
  agent = stagehand.agent(
      model="computer-use-preview"
  )

  # 使用该代理执行任务
  result = await agent.execute("Extract the top contributor's username")
  print(result)
  ```
</CodeGroup>

<CardGroup>
  <Card title="Stagehand + Computer Use 文档" href="/zh/best-practices/computer-use" icon="scroll">
    查看我们的文档，了解如何在 Stagehand 中使用 Computer Use 模型。
  </Card>

  <Card title="CUA 浏览器演示" href="https://cua.browserbase.com/" icon="brain-circuit">
    查看由 OpenAI 的 Computer Using Agent（CUA）模型控制的 Browserbase 浏览器在线演示。
  </Card>
</CardGroup>

## 顺序工具调用（Open Operator）

2025 年 1 月，Browserbase 发布了 [Open Operator](https://operator.browserbase.com)。
Open Operator 能够基于浏览器状态进行推理并采取相应操作，以完成诸如“帮我点一份披萨”这样的复杂任务。
其工作方式是按顺序调用 Stagehand 工具：

1. 如果没有 URL，则跳转到默认 URL。
2. 检查浏览器状态，并让 LLM 推理下一步该做什么。
3. 使用 `page.act()` 执行 LLM 建议的操作。
4. 重复以上步骤

<Excalidraw className="w-full" url="https://link.excalidraw.com/readonly/dKh5sB1gEM1EjVqRCGKn" />

将 `stagehand.agent` 融入你的浏览器自动化就像添加一行代码一样简单：

<Note>
  Python 目前通过 Computer Use Agent（CUA）模型支持 `stagehand.agent`。默认实现即将推出。
</Note>

<CodeGroup>
  ```typescript TypeScript
  await stagehand.page.goto("https://github.com/browserbase/stagehand");

  // Open Operator 将使用 Stagehand 配置中的默认 LLM
  const operator = stagehand.agent();
  const { message, actions } = await operator.execute(
  	"Extract the top contributor's username"
  );

  console.log(message);
  ```
</CodeGroup>

### 回放代理的操作

你可以像使用常规 Stagehand 代理那样完整回放其操作。你甚至可以自动缓存这些操作，以避免在重复运行时产生不必要的 LLM 调用。

下面使用 `replay` 函数将操作保存到一个 Stagehand 脚本文件中，它将复现代理执行过的相同行为，并内置操作缓存。

<Accordion title="utils.ts">
  ```typescript
  import { AgentAction, AgentResult } from "@browserbasehq/stagehand";
  import { exec } from "child_process";
  import fs from "fs/promises";

  export async function replay(result: AgentResult) {
    const history = result.actions;
    const replay = history
      .map((action: AgentAction) => {
        switch (action.type) {
          case "act":
            if (!action.playwrightArguments) {
              throw new Error("No playwright arguments provided");
            }
            return `await page.act(${JSON.stringify(
              action.playwrightArguments
            )})`;
          case "extract":
            return `await page.extract("${action.parameters}")`;
          case "goto":
            return `await page.goto("${action.parameters}")`;
          case "wait":
            return `await page.waitForTimeout(${parseInt(
              action.parameters as string
            )})`;
          case "navback":
            return `await page.goBack()`;
          case "refresh":
            return `await page.reload()`;
          case "close":
            return `await stagehand.close()`;
          default:
            return `await stagehand.oops()`;
        }
      })
      .join("\n");

    console.log("Replay:");
    const boilerplate = `
  import { Page, BrowserContext, Stagehand } from "@browserbasehq/stagehand";

  export async function main(stagehand: Stagehand) {
      const page = stagehand.page
  	${replay}
  }
    `;
    await fs.writeFile("replay.ts", boilerplate);

    // 使用 Prettier 格式化回放文件
    await new Promise((resolve, reject) => {
      exec(
        "npx prettier --write replay.ts",
        (error: any, stdout: any, stderr: any) => {
          if (error) {
            console.error(`Error formatting replay.ts: ${error}`);
            reject(error);
            return;
          }
          resolve(stdout);
        }
      );
    });
  }
  ```
</Accordion>

以下是类似“Get me the stock price of NVDA”这类指令的回放输出：

```typescript {14-22} replay.ts
import { Page, BrowserContext, Stagehand } from "@browserbasehq/stagehand";

export async function main({
  page,
  context,
  stagehand,
}: {
  page: Page; // 具有 act、extract 和 observe 方法的 Playwright Page
  context: BrowserContext; // Playwright BrowserContext
  stagehand: Stagehand; // Stagehand 实例
}) {
  await page.goto("https://www.google.com");

  // 回放将优先使用 Playwright，以避免不必要的 LLM 调用！
  // 如果 Playwright 操作失败，Stagehand AI 将接管并自愈
  await page.act({
    description: "用户可输入查询的搜索下拉框。",
    method: "fill",
    arguments: ["NVDA stock price"],
    selector:
      "xpath=/html/body[1]/div[1]/div[3]/form[1]/div[1]/div[1]/div[1]/div[1]/div[2]/textarea[1]",
  });
  await page.extract(
    "搜索建议中显示的 NVDA 股价",
  );
  await stagehand.close();
}
```