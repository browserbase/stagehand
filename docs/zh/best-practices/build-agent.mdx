---
title: "构建网页浏览代理"
description: "使用 Stagehand 构建可自主控制浏览器的 AI 代理"
---

import { Excalidraw } from '/snippets/excalidraw.mdx';

Stagehand 为 AI 代理提供了强大的工具，能够完全自主地控制浏览器。请观看下方演示：一个 Stagehand 代理如何自主打开指定 URL、在页面上执行操作，并提取结构化数据来回答问题。
用 Stagehand 构建代理有多种方式。我们来看看其中的一些。

![Agent](/media/stagehand-agent.gif)

## Stagehand MCP

上面的示例是一个使用 Stagehand 控制浏览器的 Claude 代理。在撰写本文时，[多模态工具调用](https://sdk.vercel.ai/docs/ai-sdk-core/tools-and-tool-calling#multi-modal-tool-results) 仅在 Claude 3.5/3.7 Sonnet 中受支持。
这意味着 Claude 足够智能，能在需要时请求浏览器截图，并据此判断下一步应执行的操作。

<CardGroup>
  <Card title="Browserbase MCP" href="https://github.com/browserbase/mcp-server-browserbase/" icon="hand-horns">
    使用由 Stagehand 驱动的 Browserbase MCP 控制浏览器
  </Card>
</CardGroup>

更有意思的是，代理能够将对浏览器状态的推理与执行动作解耦！\
Claude 负责推理浏览器状态，而 Stagehand 则可使用 GPT-4o-mini 或计算机使用模型在页面上执行操作。\
Stagehand 甚至能智能选择何时使用 GPT-4o-mini、何时使用计算机使用模型，例如在检测到 iframes 时。

<Excalidraw className="w-full aspect-video" url="https://link.excalidraw.com/readonly/GWQWmWUBqMBEAamlWsIM?darkMode=true" />

我们发现让 Claude 作为“Trajectory”代理，在合适的时机调用 Stagehand 工具，效果非常出色！\
虽然 MCP 仍处于早期阶段，但我们对其发展前景充满期待。

## Stagehand + 计算机使用模型

使用 Stagehand，只需一行代码即可调用 OpenAI 和 Anthropic 的强大计算机使用 API。

<CodeGroup>
  ```typescript TypeScript
  await page.goto("https://github.com/browserbase/stagehand");

  // Create a Computer Use agent with just one line of code!
  const agent = stagehand.agent({
  	provider: "openai",
  	model: "computer-use-preview"
  });

  // Use the agent to execute a task
  const result = await agent.execute("Extract the top contributor's username");
  console.log(result);
  ```

  ```python Python
  await page.goto("https://github.com/browserbase/stagehand-python")

  # Create a Computer Use agent with just one line of code!
  agent = stagehand.agent(
      model="computer-use-preview"
  )

  # Use the agent to execute a task
  result = await agent.execute("Extract the top contributor's username")
  print(result)
  ```
</CodeGroup>

<CardGroup>
  <Card title="Stagehand + 计算机使用文档" href="/zh/best-practices/computer-use" icon="scroll">
    查看我们的文档，了解如何将计算机使用模型与 Stagehand 结合使用。
  </Card>

  <Card title="CUA 浏览器演示" href="https://cua.browserbase.com/" icon="brain-circuit">
    查看由 OpenAI 的 Computer Using Agent（CUA）模型控制的 Browserbase 浏览器的在线演示。
  </Card>
</CardGroup>

## 顺序工具调用（Open Operator）

2025 年 1 月，Browserbase 发布了 [Open Operator](https://operator.browserbase.com)。
Open Operator 能够基于浏览器状态进行推理，并据此采取行动来完成更复杂的任务，例如“帮我点一份披萨”。
它通过按顺序调用 Stagehand 工具来工作：

1. 若没有 URL，则访问默认 URL。
2. 检查浏览器状态，并让 LLM 推理下一步该做什么。
3. 使用 `page.act()` 执行 LLM 建议的操作。
4. 重复以上步骤

<Excalidraw className="w-full" url="https://link.excalidraw.com/readonly/dKh5sB1gEM1EjVqRCGKn" />

将 `stagehand.agent` 融入你的浏览器自动化，就像添加一行代码一样简单：

<Note>
  Python 目前通过 Computer Use Agent（CUA）模型支持 `stagehand.agent`。默认实现即将推出。
</Note>

<CodeGroup>
  ```typescript TypeScript
  await stagehand.page.goto("https://github.com/browserbase/stagehand");

  // Open Operator 将使用 Stagehand 配置中的默认 LLM
  const operator = stagehand.agent();
  const { message, actions } = await operator.execute(
  	"Extract the top contributor's username"
  );

  console.log(message);
  ```
</CodeGroup>

### 回放代理的操作

你可以像使用常规 Stagehand 代理一样回放代理的操作。你甚至可以自动缓存这些操作，以在重复运行时避免不必要的 LLM 调用。

下面我们使用 `replay` 函数将操作保存为一个 Stagehand 脚本文件，它会重现代理执行过的相同行为，并内置操作缓存。

<Accordion title="utils.ts">
  ```typescript
  import { AgentAction, AgentResult } from "@browserbasehq/stagehand";
  import { exec } from "child_process";
  import fs from "fs/promises";

  export async function replay(result: AgentResult) {
    const history = result.actions;
    const replay = history
      .map((action: AgentAction) => {
        switch (action.type) {
          case "act":
            if (!action.playwrightArguments) {
              throw new Error("No playwright arguments provided");
            }
            return `await page.act(${JSON.stringify(
              action.playwrightArguments
            )})`;
          case "extract":
            return `await page.extract("${action.parameters}")`;
          case "goto":
            return `await page.goto("${action.parameters}")`;
          case "wait":
            return `await page.waitForTimeout(${parseInt(
              action.parameters as string
            )})`;
          case "navback":
            return `await page.goBack()`;
          case "refresh":
            return `await page.reload()`;
          case "close":
            return `await stagehand.close()`;
          default:
            return `await stagehand.oops()`;
        }
      })
      .join("\n");

    console.log("Replay:");
    const boilerplate = `
  import { Page, BrowserContext, Stagehand } from "@browserbasehq/stagehand";

  export async function main(stagehand: Stagehand) {
      const page = stagehand.page
  	${replay}
  }
    `;
    await fs.writeFile("replay.ts", boilerplate);

    // 使用 prettier 格式化回放文件
    await new Promise((resolve, reject) => {
      exec(
        "npx prettier --write replay.ts",
        (error: any, stdout: any, stderr: any) => {
          if (error) {
            console.error(\`Error formatting replay.ts: \${error}\`);
            reject(error);
            return;
          }
          resolve(stdout);
        }
      );
    });
  }
  ```
</Accordion>

下面是类似于“Get me the stock price of NVDA”这条指令的回放输出：

```typescript {14-22} replay.ts
import { Page, BrowserContext, Stagehand } from "@browserbasehq/stagehand";

export async function main({
  page,
  context,
  stagehand,
}: {
  page: Page; // 具备 act、extract 和 observe 方法的 Playwright Page
  context: BrowserContext; // Playwright BrowserContext
  stagehand: Stagehand; // Stagehand 实例
}) {
  await page.goto("https://www.google.com");

  // 回放将优先使用 Playwright，以避免不必要的 LLM 调用！
  // 如果 Playwright 操作失败，Stagehand AI 将接手并自愈
  await page.act({
    description: "用户输入查询的搜索框（组合框）。",
    method: "fill",
    arguments: ["NVDA stock price"],
    selector:
      "xpath=/html/body[1]/div[1]/div[3]/form[1]/div[1]/div[1]/div[1]/div[1]/div[2]/textarea[1]",
  });
  await page.extract(
    "搜索建议中显示的 NVDA 股价",
  );
  await stagehand.close();
}
```