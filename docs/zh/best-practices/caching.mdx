---
title: 操作缓存
description: 你可以在 Stagehand 中缓存操作，以避免重复的 LLM 调用。
---

在 Stagehand 中缓存操作适用于运行成本高的场景，或当底层 DOM 结构预计不会变化时。

## 使用 `observe` 预览操作
`observe()` 让你在执行前先预览操作。如果对预览结果满意，可以直接在 `page.act()` 中运行它，无需再次调用 LLM。

<CodeGroup>
```typescript TypeScript
const [actionPreview] = await page.observe("Click the quickstart link");

/** actionPreview 是 Playwright 操作的 JSON 化版本：
{
	description: "The quickstart link",
	method: "click",
	selector: "/html/body/div[1]/div[1]/a",
	arguments: [],
}
**/

// 在对预览调用 act 时不会触发 LLM 推理
await page.act(actionPreview)
```

```python Python
actions = await page.observe("Click the quickstart link")
action_preview = actions[0]

# action_preview 是 Playwright 操作的字典形式：
# {
#	"description": "The quickstart link",
#	"method": "click",
#	"selector": "/html/body/div[1]/div[1]/a",
#	"arguments": [],
# }

# 在对预览调用 act 时不会触发 LLM 推理
await page.act(action_preview)
```
</CodeGroup>

## 简单缓存

在这个示例中，我们使用一个简单的文件型缓存。我们将编写用于读取和写入 JSON 文件的 getter 和 setter 函数：

<CodeGroup>
```typescript TypeScript
// 获取缓存值（如果不存在则为 undefined）
async function getCache(key: string): Promise<ObserveResult | undefined> {
  try {
    const cache = await readFile("cache.json");
    const parsed = JSON.parse(cache);
    return parsed[key];
  } catch {
    return undefined;
  }
}

// 设置缓存值
async function setCache(key: string, value: ObserveResult): Promise<void> {
  const cache = await readFile("cache.json");
  const parsed = JSON.parse(cache);
  parsed[key] = value;
  await writeFile("cache.json", JSON.stringify(parsed));
}
```

```python Python
# 获取缓存值（如果不存在则为 None）
async def get_cache(key: str) -> Optional[Dict[str, Any]]:
    try:
        async with aiofiles.open("cache.json", 'r') as f:
            cache_content = await f.read()
            parsed = json.loads(cache_content)
            return parsed.get(key)
    except (FileNotFoundError, json.JSONDecodeError):
        return None

# 设置缓存值
async def set_cache(key: str, value: Dict[str, Any]) -> None:
    try:
        async with aiofiles.open("cache.json", 'r') as f:
            cache_content = await f.read()
            parsed = json.loads(cache_content)
    except (FileNotFoundError, json.JSONDecodeError):
        parsed = {}
    
    parsed[key] = value
    
    async with aiofiles.open("cache.json", 'w') as f:
        await f.write(json.dumps(parsed))
```
</CodeGroup>

### 使用缓存执行 act
我们来写一个函数，它会检查缓存、获取动作并执行。如果动作失败，我们将尝试“自愈”，即直接用 `page.act` 重试。

<CodeGroup>
```typescript TypeScript
// 检查缓存，获取动作并执行
// 如果 selfHeal 为 true，动作失败时将尝试自愈
async function actWithCache(page: Page, key: string, prompt: string, selfHeal = false) {
	try {
		const cacheExists = await getCache(key);

		let action: ObserveResult;
		if (cacheExists) {
			// 获取缓存的动作
			action = await getCache(prompt);
		} else {
			// 获取 observe() 的结果（该动作）
			[action] = await page.observe(prompt);

			// 缓存该动作
			await setCache(prompt, action);
		}

		// 执行该动作（无 LLM 推理）
		await page.act(action);
	} catch (e) {
		console.error(e);
		// 在 selfHeal 模式下将重试该动作
		if (selfHeal) {
			console.log("Attempting to self-heal...");
			await page.act(prompt);
		} else {
			throw e;
		}
	}
}
```

```python Python
# 检查缓存，获取动作并执行
# 如果 self_heal 为 True，动作失败时将尝试自愈
async def act_with_cache(page, key: str, prompt: str, self_heal: bool = False):
    try:
        cache_exists = await get_cache(key)

        if cache_exists:
            # 获取缓存的动作
            action = await get_cache(prompt)
        else:
            # 获取 observe() 的结果（该动作）
            actions = await page.observe(prompt)
            action = actions[0]

            # 缓存该动作
            await set_cache(prompt, action)

        # 执行动作（无 LLM 推理）
        await page.act(action)
    except Exception as e:
        print(f"Error: {e}")
        # 在 self_heal 模式下将重试该动作
        if self_heal:
            print("Attempting to self-heal...")
            await page.act(prompt)
        else:
            raise e
```
</CodeGroup>

现在你可以使用 `actWithCache` 来以缓存方式执行动作：

<CodeGroup>
```typescript TypeScript
const prompt = "Click the quickstart link";
const key = prompt; // 简单的缓存键
// 优先尝试缓存动作，失败则自愈
await actWithCache(page, key, prompt);
```

```python Python
prompt = "Click the quickstart link"
key = prompt  # 简单的缓存键
# 优先尝试缓存动作，失败则自愈
await act_with_cache(page, key, prompt)
```
</CodeGroup>

## 高级缓存

上面的示例较为基础，但你可能希望根据页面内容来缓存操作。另外，如果存在重复的提示，你应当使用更具唯一性的键。

我们希望将缓存逻辑交由你自行决定，同时提供实现自定义缓存策略所需的一切工具。

你可以直接通过 Playwright 的 page 对象访问 DOM 和可访问性树。下面是访问页面内容的示例：

<CodeGroup>
```typescript TypeScript
// Get the page content
const pageContent = await page.content();
```

```python Python
# Get the page content
page_content = await page.content()
```
</CodeGroup>

你也可以结合可访问性树、DOM 或其他任意信息来构造更独特的键。实现方式可按需调整，整体思路与上述示例非常相似。