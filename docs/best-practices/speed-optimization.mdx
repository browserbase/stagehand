---
title: Speed Optimization
sidebarTitle: Speed Optimization
description: Optimize Stagehand performance for faster automation and reduced latency
---

Stagehand performance depends on several factors: DOM processing speed, LLM inference time, browser operations, and network latency. This guide provides proven strategies to maximize automation speed.

## Quick Performance Wins

### 1. Use Cached Actions

The fastest action is one that doesn't require LLM inference. Cache successful actions with `observe` and reuse them:

<CodeGroup>
```typescript TypeScript
// Cache the action first time
const [action] = await page.observe("Click the login button");
await setCache("login_button", action);

// Instant execution on subsequent runs (no LLM cost or delay)
const cachedAction = await getCache("login_button");
if (cachedAction) {
  await page.act(cachedAction); // ~10ms vs ~2000ms
}
```
```python Python
# Cache the action first time  
actions = await page.observe("Click the login button")
action = actions[0]
await set_cache("login_button", action)

# Instant execution on subsequent runs (no LLM cost or delay)
cached_action = await get_cache("login_button")
if cached_action:
    await page.act(cached_action)  # ~10ms vs ~2000ms
```
</CodeGroup>

<Card title="Caching Guide" icon="database" href="/best-practices/caching">
  Learn advanced caching patterns and cache invalidation strategies
</Card>

### 2. Optimize DOM Processing

Reduce DOM complexity before Stagehand processes the page:

<CodeGroup>
```typescript TypeScript
// Remove heavy elements that slow down processing
await page.evaluate(() => {
  // Remove video elements
  document.querySelectorAll('video, iframe').forEach(el => el.remove());
  
  // Hide complex animations
  document.querySelectorAll('[style*="animation"]').forEach(el => {
    (el as HTMLElement).style.animation = 'none';
  });
});

// Then perform Stagehand operations
await page.act("Click the submit button");
```
```python Python
# Remove heavy elements that slow down processing
await page.evaluate("""() => {
  // Remove video elements
  document.querySelectorAll('video, iframe').forEach(el => el.remove());
  
  // Hide complex animations
  document.querySelectorAll('[style*="animation"]').forEach(el => {
    el.style.animation = 'none';
  });
}""")

# Then perform Stagehand operations
await page.act("Click the submit button")
```
</CodeGroup>

### 3. Set Appropriate Timeouts

Use shorter timeouts for simple operations:

<CodeGroup>
```typescript TypeScript
// Fast operations - reduce timeout
await page.act("Click button", { 
  domSettleTimeoutMs: 100  // Default is 500ms
});

// Complex page loads - increase timeout
await page.goto("https://heavy-spa.com", {
  waitUntil: "domcontentloaded" // Don't wait for all resources
});
```
```python Python
# Fast operations - reduce timeout
await page.act("Click button", dom_settle_timeout_ms=100)

# Complex page loads - increase timeout  
await page.goto("https://heavy-spa.com", wait_until="domcontentloaded")
```
</CodeGroup>

## Advanced Performance Strategies

### Parallel Operations

Execute independent operations concurrently:

<CodeGroup>
```typescript TypeScript
// Instead of sequential operations
await page.act("Fill name field");
await page.act("Fill email field");
await page.act("Select country dropdown");

// Use parallel observe + act for independent fields
const [nameAction, emailAction, countryAction] = await Promise.all([
  page.observe("Fill name field"),
  page.observe("Fill email field"),
  page.observe("Select country dropdown")
]);

await Promise.all([
  page.act(nameAction[0]),
  page.act(emailAction[0]), 
  page.act(countryAction[0])
]);
```
```python Python
import asyncio

# Instead of sequential operations
await page.act("Fill name field")
await page.act("Fill email field")
await page.act("Select country dropdown")

# Use parallel observe + act for independent fields
name_action, email_action, country_action = await asyncio.gather(
    page.observe("Fill name field"),
    page.observe("Fill email field"),
    page.observe("Select country dropdown")
)

await asyncio.gather(
    page.act(name_action[0]),
    page.act(email_action[0]),
    page.act(country_action[0])
)
```
</CodeGroup>

### Smart Model Selection

Use faster models for simple tasks, premium models only when needed:

<CodeGroup>
```typescript TypeScript
class SpeedOptimizedStagehand {
  private fastModel: Stagehand;
  private premiumModel: Stagehand;

  async smartAct(page: Page, prompt: string, complexity: 'simple' | 'complex') {
    const model = complexity === 'simple' ? this.fastModel : this.premiumModel;
    return await model.page.act(prompt);
  }
}

// Use fast model for simple clicks/forms
await stagehand.smartAct(page, "Click submit", 'simple');

// Use premium model for complex reasoning
await stagehand.smartAct(page, "Find the cheapest flight option", 'complex');
```
```python Python
class SpeedOptimizedStagehand:
    def __init__(self):
        self.fast_model = Stagehand(model_name="fast-model")
        self.premium_model = Stagehand(model_name="premium-model")
    
    async def smart_act(self, page, prompt: str, complexity: str):
        model = self.fast_model if complexity == 'simple' else self.premium_model
        return await model.page.act(prompt)

# Use fast model for simple clicks/forms
await stagehand.smart_act(page, "Click submit", 'simple')

# Use premium model for complex reasoning  
await stagehand.smart_act(page, "Find the cheapest flight option", 'complex')
```
</CodeGroup>

### Preload and Reuse Sessions

Minimize session setup overhead:

<CodeGroup>
```typescript TypeScript
class SessionPool {
  private sessions: Stagehand[] = [];
  private sessionIndex = 0;

  async getOptimizedSession(): Promise<Stagehand> {
    if (this.sessions.length === 0) {
      // Pre-warm multiple sessions
      const sessionPromises = Array(3).fill(null).map(async () => {
        const stagehand = new Stagehand({
          env: "BROWSERBASE",
          browserbaseSessionCreateParams: {
            keepAlive: true, // Reuse sessions
          }
        });
        await stagehand.init();
        return stagehand;
      });
      
      this.sessions = await Promise.all(sessionPromises);
    }

    // Round-robin session usage
    const session = this.sessions[this.sessionIndex];
    this.sessionIndex = (this.sessionIndex + 1) % this.sessions.length;
    return session;
  }
}
```
```python Python
class SessionPool:
    def __init__(self):
        self.sessions = []
        self.session_index = 0
    
    async def get_optimized_session(self):
        if not self.sessions:
            # Pre-warm multiple sessions
            session_tasks = []
            for _ in range(3):
                stagehand = Stagehand(
                    env="BROWSERBASE",
                    browserbase_session_create_params={
                        "keep_alive": True
                    }
                )
                session_tasks.append(stagehand.init())
            
            await asyncio.gather(*session_tasks)
            self.sessions = [task.result() for task in session_tasks]
        
        # Round-robin session usage
        session = self.sessions[self.session_index]
        self.session_index = (self.session_index + 1) % len(self.sessions)
        return session
```
</CodeGroup>

## Performance Monitoring

Track performance metrics to identify bottlenecks:

<CodeGroup>
```typescript TypeScript
class PerformanceTracker {
  private metrics: Map<string, number[]> = new Map();

  async timedAct(page: Page, prompt: string): Promise<ActResult> {
    const start = Date.now();
    const result = await page.act(prompt);
    const duration = Date.now() - start;
    
    if (!this.metrics.has(prompt)) {
      this.metrics.set(prompt, []);
    }
    this.metrics.get(prompt)!.push(duration);
    
    console.log(`Action "${prompt}" took ${duration}ms`);
    return result;
  }

  getAverageTime(prompt: string): number {
    const times = this.metrics.get(prompt) || [];
    return times.reduce((a, b) => a + b, 0) / times.length;
  }
}
```
```python Python
import time
from collections import defaultdict

class PerformanceTracker:
    def __init__(self):
        self.metrics = defaultdict(list)
    
    async def timed_act(self, page, prompt: str):
        start = time.time()
        result = await page.act(prompt)
        duration = (time.time() - start) * 1000  # Convert to ms
        
        self.metrics[prompt].append(duration)
        print(f'Action "{prompt}" took {duration:.0f}ms')
        return result
    
    def get_average_time(self, prompt: str) -> float:
        times = self.metrics[prompt]
        return sum(times) / len(times) if times else 0
```
</CodeGroup>

## Infrastructure Optimizations

### Browserbase Configuration

Optimize browser infrastructure for speed:

<CodeGroup>
```typescript TypeScript
const stagehand = new Stagehand({
  env: "BROWSERBASE",
  browserbaseSessionCreateParams: {
    // Faster startup
    projectId: process.env.BROWSERBASE_PROJECT_ID,
    
    // Optimize for speed over isolation
    proxied: false,
    
    // Reduce resource usage
    blockResources: ["image", "font", "media"],
    
    // Keep sessions warm
    keepAlive: true,
    
    // Shorter timeout for fast tasks
    timeout: 300, // 5 minutes instead of default
  }
});
```
```python Python
stagehand = Stagehand(
    env="BROWSERBASE",
    browserbase_session_create_params={
        # Faster startup
        "project_id": os.getenv("BROWSERBASE_PROJECT_ID"),
        
        # Optimize for speed over isolation
        "proxied": False,
        
        # Reduce resource usage
        "block_resources": ["image", "font", "media"],
        
        # Keep sessions warm
        "keep_alive": True,
        
        # Shorter timeout for fast tasks
        "timeout": 300,  # 5 minutes instead of default
    }
)
```
</CodeGroup>

### Page Load Optimization

Skip unnecessary resources during page loads:

<CodeGroup>
```typescript TypeScript
// Block heavy resources globally
await context.route('**/*', (route) => {
  const resourceType = route.request().resourceType();
  if (['image', 'font', 'media'].includes(resourceType)) {
    route.abort();
  } else {
    route.continue();
  }
});

// Use faster navigation
await page.goto(url, { 
  waitUntil: 'domcontentloaded',  // Don't wait for images/fonts
  timeout: 10000 
});
```
```python Python
# Block heavy resources globally
async def handle_route(route):
    resource_type = route.request.resource_type
    if resource_type in ['image', 'font', 'media']:
        await route.abort()
    else:
        await route.continue_()

await context.route('**/*', handle_route)

# Use faster navigation
await page.goto(url, 
    wait_until='domcontentloaded',  # Don't wait for images/fonts
    timeout=10000
)
```
</CodeGroup>

## Common Performance Pitfalls

### Avoid These Slowdowns

❌ **Sequential operations that could be parallel**
```typescript
// Slow: ~6000ms total
await page.act("Fill field 1");
await page.act("Fill field 2"); 
await page.act("Fill field 3");
```

✅ **Parallel operations**
```typescript
// Fast: ~2000ms total
const actions = await Promise.all([
  page.observe("Fill field 1"),
  page.observe("Fill field 2"),
  page.observe("Fill field 3")
]);

await Promise.all(actions.map(([action]) => page.act(action)));
```

❌ **Over-specific selectors requiring complex reasoning**
```typescript
// Slow: Complex reasoning required
await page.act("Click the blue button in the third row of the table");
```

✅ **Simple, direct selectors**
```typescript
// Fast: Clear, simple target
await page.act("Click the Submit button");
```

## Performance Benchmarking

Measure your optimization impact:

<CodeGroup>
```typescript TypeScript
// Before optimization
console.time("workflow");
await page.act("Fill form");
await page.act("Click submit");
await page.act("Confirm submission");
console.timeEnd("workflow"); // 8000ms

// After optimization with caching
console.time("workflow-optimized");
const [fillAction, submitAction, confirmAction] = await Promise.all([
  getCachedAction("fill_form"),
  getCachedAction("submit_button"),
  getCachedAction("confirm_button")
]);

await Promise.all([
  page.act(fillAction),
  page.act(submitAction),
  page.act(confirmAction)
]);
console.timeEnd("workflow-optimized"); // 500ms
```
```python Python
import time

# Before optimization  
start = time.time()
await page.act("Fill form")
await page.act("Click submit") 
await page.act("Confirm submission")
print(f"Workflow took {(time.time() - start) * 1000:.0f}ms")  # 8000ms

# After optimization with caching
start = time.time()
fill_action, submit_action, confirm_action = await asyncio.gather(
    get_cached_action("fill_form"),
    get_cached_action("submit_button"), 
    get_cached_action("confirm_button")
)

await asyncio.gather(
    page.act(fill_action),
    page.act(submit_action),
    page.act(confirm_action)
)
print(f"Optimized workflow took {(time.time() - start) * 1000:.0f}ms")  # 500ms
```
</CodeGroup>

## Related Resources

<CardGroup cols={2}>
<Card title="Caching Strategies" icon="database" href="/best-practices/caching">
  Advanced caching patterns for maximum performance
</Card>

<Card title="Cost Optimization" icon="dollar-sign" href="/best-practices/cost-optimization">
  Balance speed improvements with cost considerations
</Card>

<Card title="Browser Configuration" icon="window-maximize" href="/configuration/browser">
  Optimize Browserbase settings for speed
</Card>

<Card title="Model Selection" icon="brain" href="/configuration/models">
  Choose the right model for speed vs accuracy
</Card>
</CardGroup>