---
title: Observability
sidebarTitle: Observability
description: Track Stagehand automation with session visibility and analytics
---

Stagehand provides powerful observability features to help you monitor, track performance, and analyze your browser automation workflows. Focus on session monitoring, resource usage, and operational insights for both Browserbase and local environments.

## Browserbase Session Monitoring

When running on Browserbase, you gain access to comprehensive cloud-based monitoring and session management through the Browserbase API and dashboard.

<div style={{ textAlign: "center" }}>
  <img src="/media/observability.gif" alt="Browserbase Session Observability" width="400" />
</div>

### Live Session Visibility

Browserbase provides real-time visibility into your automation sessions:

**Session Dashboard Features**
- Real-time browser screen recording and replay
- Network request monitoring with detailed timing
- JavaScript console logs and error tracking
- CPU and memory usage metrics
- Session status and duration tracking

**Session Management & API Access**
```typescript
import { Stagehand } from "@browserbasehq/stagehand";
import { Browserbase } from "@browserbasehq/sdk";

const browserbase = new Browserbase({
  apiKey: process.env.BROWSERBASE_API_KEY,
});

const stagehand = new Stagehand({
  env: "BROWSERBASE"
});

await stagehand.init();

const sessionInfo = await browserbase.sessions.retrieve(stagehand.sessionId);

console.log("Session status:", sessionInfo.status);
console.log("Session region:", sessionInfo.region);
console.log("CPU usage:", sessionInfo.avgCpuUsage);
console.log("Memory usage:", sessionInfo.memoryUsage);
console.log("Proxy bytes:", sessionInfo.proxyBytes);
```

### Session Analytics & Insights

<CardGroup>
  <Card title="Real-Time Monitoring" icon="chart-line">
    Monitor live session status, resource usage, and geographic distribution. Scale and manage concurrent sessions with real-time insights.
  </Card>

  <Card title="Session Recordings" icon="video">
    Review complete session recordings with frame-by-frame playback. Analyze network requests and debug browser interactions visually.
  </Card>

  <Card title="API Management" icon="code">
    Programmatically access session data, automate lifecycle management, and integrate with monitoring systems through our API.
  </Card>

  <Card title="Usage Monitoring" icon="chart-bar">
    Track resource consumption, session duration, and API usage. Get detailed breakdowns of costs and utilization across your automation.
  </Card>
</CardGroup>

### Session Monitoring & Filtering

Query and monitor sessions by status and metadata:

```typescript
import { Browserbase } from "@browserbasehq/sdk";

const browserbase = new Browserbase({
  apiKey: process.env.BROWSERBASE_API_KEY,
});

// List sessions with filtering
async function getFilteredSessions() {
  const sessions = await browserbase.sessions.list({
    status: 'RUNNING'
  });
  
  return sessions.map(session => ({
    id: session.id,
    status: session.status, // RUNNING, COMPLETED, ERROR, TIMED_OUT
    startedAt: session.startedAt,
    endedAt: session.endedAt,
    region: session.region,
    avgCpuUsage: session.avgCpuUsage,
    memoryUsage: session.memoryUsage,
    proxyBytes: session.proxyBytes,
    userMetadata: session.userMetadata
  }));
}

// Query sessions by metadata
async function querySessionsByMetadata(query: string) {
  const sessions = await browserbase.sessions.list({
    q: query
  });
  
  return sessions;
}
```

## Local Environment Monitoring

For local development, Stagehand provides performance monitoring and resource tracking capabilities directly on your machine.

### Performance Tracking

```typescript
import { Stagehand } from "@browserbasehq/stagehand";

const stagehand = new Stagehand({
  env: "LOCAL",
  verbose: 1, // Monitor performance without debug noise
});

await stagehand.init();

// Track local automation metrics
const startTime = Date.now();
const initialMetrics = await stagehand.metrics;

// ... perform automation tasks
const page = stagehand.page;
await page.goto("https://example.com");
await page.act("click button");
await page.extract({ instruction: "get data", schema: DataSchema });

const finalMetrics = await stagehand.metrics;
const executionTime = Date.now() - startTime;

console.log('Local Performance Summary:', {
  executionTime: `${executionTime}ms`,
  totalTokens: finalMetrics.totalPromptTokens + finalMetrics.totalCompletionTokens,
  totalInferenceTime: `${finalMetrics.totalInferenceTimeMs}ms`,
  tokensPerSecond: ((finalMetrics.totalPromptTokens + finalMetrics.totalCompletionTokens) / (executionTime / 1000)).toFixed(2)
});
```

## Resource Usage Monitoring

When running locally, monitor system resource usage and browser performance:

```typescript
import { Stagehand } from "@browserbasehq/stagehand";
import * as os from 'os';
import { performance } from 'perf_hooks';

class LocalResourceMonitor {
  private cpuUsage: number[] = [];
  private memoryUsage: number[] = [];
  
  startMonitoring() {
    const interval = setInterval(() => {
      // Track system resources
      const memUsage = process.memoryUsage();
      this.memoryUsage.push(memUsage.heapUsed / 1024 / 1024); // MB
      
      // Track CPU (simplified)
      const loadAvg = os.loadavg()[0];
      this.cpuUsage.push(loadAvg);
    }, 1000);
    
    return interval;
  }
  
  getResourceSummary() {
    return {
      avgMemoryUsage: this.memoryUsage.reduce((a, b) => a + b, 0) / this.memoryUsage.length,
      peakMemoryUsage: Math.max(...this.memoryUsage),
      avgCpuLoad: this.cpuUsage.reduce((a, b) => a + b, 0) / this.cpuUsage.length,
      totalDataPoints: this.cpuUsage.length
    };
  }
}

const monitor = new LocalResourceMonitor();
const interval = monitor.startMonitoring();

const stagehand = new Stagehand({ env: "LOCAL" });

// ... run automation

clearInterval(interval);
console.log('Resource Usage:', monitor.getResourceSummary());
```


  <Card title="LLM Usage" icon="chart-line" href="/configuration/evals">
    Monitor token usage, costs, and speed. Set up automated alerting for critical failures. Implement cost tracking across different environments. Use session analytics to optimize automation workflows.
  </Card>


## Real-Time Metrics & Monitoring

### Basic Usage Tracking

Monitor your automation's resource usage in real-time with `stagehand.metrics`:

```typescript
import { Stagehand } from "@browserbasehq/stagehand";

const stagehand = new Stagehand({ env: "BROWSERBASE" });
await stagehand.init();

// Metrics are async in V3
const metrics = await stagehand.metrics;
console.log(metrics);

// Monitor during automation
const startTime = Date.now();
const initialMetrics = await stagehand.metrics;

// ... perform automation tasks
const page = stagehand.page;
await page.goto("https://example.com");
await page.act("click the login button");
const data = await page.extract({
  instruction: "extract user info",
  schema: UserSchema
});

const finalMetrics = await stagehand.metrics;
const executionTime = Date.now() - startTime;

console.log('Automation Summary:', {
  totalTokens: finalMetrics.totalPromptTokens + finalMetrics.totalCompletionTokens,
  executionTime: `${executionTime}ms`,
  avgInferenceTime: `${finalMetrics.totalInferenceTimeMs / 3}ms`,
});
```

### Understanding Metrics Data

The metrics object provides detailed breakdown by Stagehand operation:

```typescript
interface V3Metrics {
  // Act operation metrics
  actPromptTokens: number;
  actCompletionTokens: number;
  actInferenceTimeMs: number;

  // Extract operation metrics
  extractPromptTokens: number;
  extractCompletionTokens: number;
  extractInferenceTimeMs: number;

  // Observe operation metrics
  observePromptTokens: number;
  observeCompletionTokens: number;
  observeInferenceTimeMs: number;

  // Agent operation metrics
  agentPromptTokens: number;
  agentCompletionTokens: number;
  agentInferenceTimeMs: number;

  // Cumulative totals
  totalPromptTokens: number;
  totalCompletionTokens: number;
  totalInferenceTimeMs: number;
}
```

**Example metrics output:**

```typescript
const metrics = await stagehand.metrics;
console.log(metrics);

// {
//   actPromptTokens: 4011,
//   actCompletionTokens: 51,
//   actInferenceTimeMs: 1688,
//   extractPromptTokens: 4200,
//   extractCompletionTokens: 243,
//   extractInferenceTimeMs: 4297,
//   observePromptTokens: 347,
//   observeCompletionTokens: 43,
//   observeInferenceTimeMs: 903,
//   agentPromptTokens: 0,
//   agentCompletionTokens: 0,
//   agentInferenceTimeMs: 0,
//   totalPromptTokens: 8558,
//   totalCompletionTokens: 337,
//   totalInferenceTimeMs: 6888
// }
```

## History Tracking

Track all Stagehand operations with the history API. History captures every action, extraction, observation, navigation, and agent execution.

### Basic History Usage

```typescript
import { Stagehand } from "@browserbasehq/stagehand";

const stagehand = new Stagehand({ env: "BROWSERBASE" });
await stagehand.init();

// Perform some operations
const page = stagehand.page;
await page.goto("https://example.com");
await page.act("click login button");
await page.observe("find form fields");

// Get complete history (async in V3)
const history = await stagehand.history;

console.log(`Total operations: ${history.length}`);
history.forEach((entry, i) => {
  console.log(`${i + 1}. ${entry.method} at ${entry.timestamp}`);
});
```

### History Entry Structure

Each history entry contains:

```typescript
interface HistoryEntry {
  method: "act" | "extract" | "observe" | "navigate" | "agent";
  parameters: unknown;  // Input parameters for the operation
  result: unknown;      // Output/result of the operation
  timestamp: string;    // ISO timestamp of when operation occurred
}
```

### Analyzing Workflow Patterns

Use history to analyze and debug automation workflows:

```typescript
const history = await stagehand.history;

// Find all failed operations
const failures = history.filter(entry =>
  entry.result && typeof entry.result === 'object' && 'error' in entry.result
);

// Count operations by type
const operationCounts = history.reduce((acc, entry) => {
  acc[entry.method] = (acc[entry.method] || 0) + 1;
  return acc;
}, {} as Record<string, number>);

console.log('Operations:', operationCounts);
// { act: 5, extract: 2, observe: 3, navigate: 1, agent: 0 }

// Get execution timeline
const timeline = history.map(entry => ({
  method: entry.method,
  time: new Date(entry.timestamp).toLocaleTimeString()
}));
```

### Replaying Workflows

Use history to replay or resume automation workflows:

```typescript
// Save history for later replay
const history = await stagehand.history;
await fs.writeFile('workflow-history.json', JSON.stringify(history, null, 2));

// Later: analyze what happened
const savedHistory = JSON.parse(await fs.readFile('workflow-history.json', 'utf-8'));

console.log('Workflow executed these steps:');
savedHistory.forEach((entry: HistoryEntry) => {
  if (entry.method === 'act') {
    console.log(`- Action: ${JSON.stringify(entry.parameters)}`);
  } else if (entry.method === 'extract') {
    console.log(`- Extracted data`);
  }
});
```

### Detailed Inference Logging

For debugging LLM interactions and analyzing model decisions, enable inference logging:

```typescript
const stagehand = new Stagehand({
  env: "BROWSERBASE",
  logInferenceToFile: true, // Creates detailed inference logs
  verbose: 2
});
```

<Card title="Complete Logging Guide" icon="file-lines" href="/configuration/logging">
  Learn about logging configuration, inference file structure, and debugging techniques.
</Card>


## Best Practices

<AccordionGroup>
<Accordion title="Production Monitoring">
- Track session success rates and failure patterns
- Monitor resource usage and scaling requirements
- Set up automated alerting for critical failures
- Implement cost tracking across different environments
- Use session analytics to optimize automation workflows
</Accordion>

<Accordion title="Performance Optimization">
- Compare Browserbase vs local execution times
- Monitor token usage and inference costs across models
- Track geographic performance differences
- Identify bottlenecks in automation workflows
- Optimize for cost-effectiveness and speed
</Accordion>

<Accordion title="Operational Insights">
- Track session distribution across regions
- Monitor concurrent session limits and scaling
- Analyze failure patterns and common error scenarios
- Use session recordings for root cause analysis
- Implement custom metadata for workflow categorization
</Accordion>

<Accordion title="Integration & Alerting">
- Integrate session APIs with monitoring dashboards
- Set up automated notifications for session failures  
- Track SLA compliance and performance benchmarks
- Monitor resource costs and usage patterns
- Use analytics data for capacity planning and optimization
</Accordion>
</AccordionGroup>

For detailed logging and debugging capabilities, see [Logging](/configuration/logging).