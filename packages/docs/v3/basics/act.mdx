---
title: Act
description: 'Interact with a web page'
---

## What is `act()`?
``` typescript
page.act("click on add to cart")
```
`act` enables Stagehand to perform **individual** actions on a web page. Use it to build self-healing and deterministic automations that adapt to website changes. 

## Why use `act()`?

<CardGroup cols={2}>
  <Card title="Natural Language Instructions" icon="wand-magic-sparkles" href="#using-act">
    Write automation in plain English. No selectors or complex syntax.
  </Card>
  <Card title="Precise Control" icon="crosshairs" href="#best-practices">
    Build automations step by step. Define exactly what happens at every moment.
  </Card>
  <Card title="Self-Healing" icon="bandage" href="#ensure-reliable-actions">
    Actions automatically adapt when websites change.
  </Card>
  <Card title="Caching" icon="repeat" href="#reduce-model-costs">
    Cache actions to avoid LLM calls and ensure consistent execution across runs.
  </Card>
</CardGroup>

## Using `act()`

Use `act` to perform single actions in your automation. Here's how to click a button:

```typescript
await page.goto("https://example-store.com");
await page.act("click the add to cart button");
```

With `act`, breaking complex actions into small, single-step actions works best. If you need to orchestrate multi-step flows, use multiple `act` commands or `agent`.

<Accordion title="Suggested actions">

| Action | Example instruction |
|--------|---------------------|
| Click | `click the button` |
| Fill | `fill the field with <value>` |
| Type | `type <text> into the search box` |
| Press | `press <key> in the search field` |
| Scroll | `scroll to <position>` |
| Select from dropdown | `select <value> from the dropdown` |
</Accordion>

<Tabs>
<Tab title="Do this">
Break your task into single-step actions.

```typescript
// Break it into single-step actions
await page.act("open the filters panel");
await page.act("choose 4-star rating");
await page.act("click the apply button");
```
</Tab>

<Tab title="Don't do this">
For multi-step tasks, use [`agent()`](/basics/agent) instead.

```typescript
// Too complex - trying to do multiple things at once
await page.act("open the filters panel, choose 4-star rating, and click apply");
```
</Tab>
</Tabs>

### Advanced Configuration

You can pass additional options to configure the model, timeout, variables, and target page:

```typescript
// Custom model configuration
await page.act("choose 'Peach' from the favorite colour dropdown", {
  model: {
    provider: "google",
    model: "gemini-2.5-flash",
    apiKey: process.env.GOOGLE_API_KEY
  },
  timeout: 10000
});
```

<Note>
**iFrame and Shadow DOM Support** Stagehand automatically handles iFrame traversal and shadow DOM elements without requiring additional configuration.
</Note>

<Card title="Complete API Reference" icon="book" href="/v3/references/act">
  See the full `act()` reference for detailed parameter documentation, return values, and advanced examples.
</Card>





## Best practices

### Ensure reliable actions

Use `observe()` to discover candidate actions on the current page and plan reliably. It returns a list of suggested actions (with selector, description, method, and arguments). You can pass an observed action directly to `act` to execute it.

```typescript
const [action] = await page.observe("click the login button");

if (action) {
  await page.act(action);
}
```

<Card title="Analyze pages with observe()" icon="magnifying-glass" iconType="sharp-solid" href="/basics/observe">
  Plan actions with `observe()` before executing with `act`.
</Card>

### Reduce model costs

Enable automatic action caching by specifying a `cacheDir` when initializing Stagehand. The first time an action runs, it's cached. Subsequent runs reuse the cached action without LLM calls.

```typescript
import { Stagehand } from "@browserbasehq/stagehand";

// Enable caching by specifying a cache directory
const stagehand = new Stagehand({
  env: "BROWSERBASE",
  cacheDir: "act-cache" // Actions are automatically cached here
});

await stagehand.init();
const page = stagehand.page;

// First run - makes LLM call and caches the action
await page.act("click the login button");
```

<Note>
Caching persists across script executions. The first time you run your script, actions are cached to your local filesystem. On subsequent runs, cached actions are reused automatically, significantly reducing costs and improving performance.
</Note>

<Card title="Complete caching guide" icon="database" iconType="sharp-solid" href="/v3/best-practices/caching">
  Learn advanced caching techniques and patterns for optimal performance.
</Card>

### Secure your automations

Variables are **not shared with LLM providers**. Use them for passwords, API keys, and other sensitive data.

<Note>
Load sensitive data from environment variables using `.env` files. Never hardcode API keys, passwords, or other secrets directly in your code.
</Note>

```typescript
// Variables use %variableName% syntax in the instruction
await page.act("type %username% into the email field", {
  variables: { username: "user@example.com" }
});

await page.act("type %password% into the password field", {
  variables: { password: process.env.USER_PASSWORD }
});

await page.act("click the login button");
```

<Warning>
When handling sensitive data, set `verbose: 0` in your Stagehand configuration to prevent secrets from appearing in logs. See the [configuration guide](/configuration/browser) for more details.
</Warning>

<Card title="User Data Best Practices" icon="shield-check" iconType="sharp-solid" href="/best-practices/user-data">
  Complete guide to securing your browser automations with best practices and configurations.
</Card>

## Troubleshooting

<AccordionGroup>


<Accordion title="Method not supported">
**Problem**: `act` fails with "method not supported" error

**Solutions**:
- Use clear and detailed instructions for what you want to accomplish
- Review our [evals](https://stagehand.dev/evals) to find the best models for your use case
- Use [`observe()`](/basics/observe) and verify the resulting action is within a list of expected actions

**Solution 1: Validate with observe**

```typescript
const prompt = "click the submit button";
const expectedMethod = "click";

try {
  await page.act(prompt);
} catch (error) {
  if (error.message.includes("method not supported")) {
    // Observe the same prompt to get the planned action
    const [action] = await page.observe(prompt);

    if (action && action.method === expectedMethod) {
      await page.act(action);
    } else {
      throw new Error(`Unsupported method: expected "${expectedMethod}", got "${action?.method}"`);
    }
  } else {
    throw error;
  }
}
```

**Solution 2: Retry with exponential backoff**

```typescript
// Retry with exponential backoff for intermittent issues
const prompt = "click the submit button";
const maxRetries = 3;

for (let attempt = 0; attempt <= maxRetries; attempt++) {
  try {
    await page.act(prompt, { timeout: 10000 + (attempt * 5000) });
    break; // Success, exit retry loop
  } catch (error) {
    if (error.message.includes("method not supported") && attempt < maxRetries) {
      // Exponential backoff: wait 2^attempt seconds
      const delay = Math.pow(2, attempt) * 1000;
      console.log(`Retry ${attempt + 1}/${maxRetries} after ${delay}ms`);
      await new Promise(resolve => setTimeout(resolve, delay));
    } else {
      throw error;
    }
  }
}
```

</Accordion>

<Accordion title="Action failed or timed out">
**Problem**: `act` times out or fails to complete action (often due to element not found)

**Solutions**:
- Ensure page has fully loaded
- Check if content is in iframes: [Learn more about working with iframes](/best-practices/working-with-iframes)
- Increase action timeout
- Use `observe()` first to verify element exists

```typescript
// Handle timeout and element not found issues
try {
  await page.act("click the submit button", { timeout: 30000 });
} catch (error) {
  // Check if page is fully loaded
  await page.waitForLoadState('domcontentloaded');

  // Use observe to check element state
  const [element] = await page.observe("find the submit button");

  if (element) {
    console.log("Element found, trying more specific instruction");
    await page.act("click the submit button at the bottom of the form");
  } else {
    console.log("Element not found, trying alternative selector");
    await page.act("click the button with text 'Submit'");
  }
}
```
</Accordion>

<Accordion title="Incorrect element selected">
**Problem**: `act` performs action on wrong element

**Solutions**:
- Be more specific in instructions: include visual cues, position, or context
- Use `observe()` to preview which element will be selected
- Add contextual information: "the search button in the header"
- Use unique identifiers when available

```typescript
// More precise element targeting
// Instead of:
await page.act("click the button");

// Use specific context:
await page.act("click the red 'Delete' button next to the user John Smith");

// Or preview with observe first:
const [action] = await page.observe("click the submit button in the checkout form");
if (action.description.includes("checkout")) {
  await page.act(action);
}
```
</Accordion>



</AccordionGroup>

## Next steps

<CardGroup cols={2}>

  <Card title="Orchestrate complex workflows with Agent" icon="robot" iconType="sharp-solid" href="/basics/agent">
    Use `Agent` to autonomously execute multi-step tasks and complex workflows.
  </Card>

   <Card title="Caching actions" icon="bolt" iconType="sharp-solid" href="/best-practices/caching">
    Speed up repeated automations by caching actions.
  </Card>

  <Card title="Extract data with extract()" icon="table" iconType="sharp-solid" href="/basics/extract">
    Use `extract` with a data schema to pull clean, typed data from any page.
  </Card>

  <Card title="Working with iframes" icon="frame" iconType="sharp-solid" href="/best-practices/working-with-iframes">
    Learn best practices for interacting with elements inside iframes.
  </Card>
</CardGroup>